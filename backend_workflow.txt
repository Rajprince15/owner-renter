=================================================================
HOMER - BACKEND WORKFLOW
COMPLETE BACKEND API IMPLEMENTATION
=================================================================

â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                    ðŸ”§ BACKEND WORKFLOW ðŸ”§                     â•‘
â•‘                                                               â•‘
â•‘  PURPOSE: Complete backend API matching frontend contracts   â•‘
â•‘  DATABASE: MySQL/MariaDB (see homer_schema.sql)             â•‘
â•‘  INTEGRATION: Designed to work seamlessly with frontend      â•‘
â•‘               (frontend expects exact these API responses)    â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

=================================================================
TABLE OF CONTENTS
=================================================================
1. Tech Stack & Setup
2. Project Structure
3. Database Setup & Models
4. Complete API Endpoints (Matching Frontend)
5. Authentication & Authorization
6. Business Logic Services
7. Mock Data Generators (For Testing)
8. Environment Configuration
9. Testing & Deployment

=================================================================
1. TECH STACK & SETUP
=================================================================

BACKEND STACK:
- FastAPI (Python 3.9+)
- MySQL/MariaDB (Database)
- SQLAlchemy (ORM)
- PyMySQL (MySQL driver)
- Pydantic (Data validation)
- JWT (Authentication)
- Bcrypt (Password hashing)
- Python-multipart (File uploads)
- CORS middleware

SETUP COMMANDS:
```bash
cd /app/backend

# Install dependencies
pip install fastapi uvicorn sqlalchemy pymysql bcrypt python-jose[cryptography] \
    python-multipart passlib pydantic-settings python-dotenv

# Create requirements.txt
pip freeze > requirements.txt
```

ENVIRONMENT VARIABLES (.env):
```
# Application
APP_NAME=Homer
APP_ENV=development
DEBUG=true
SECRET_KEY=your-secret-key-here-change-in-production
PORT=8001

# Database (MariaDB for development)
DATABASE_URL=mysql+pymysql://root@localhost:3306/homer_db
# For production MySQL: mysql+pymysql://user:password@host:3306/homer_db

# JWT Configuration
JWT_SECRET=your-jwt-secret-here-change-in-production
JWT_ALGORITHM=HS256
JWT_EXPIRY_HOURS=24

# Payment Gateway (Mock by default)
RAZORPAY_KEY_ID=
RAZORPAY_KEY_SECRET=
RAZORPAY_WEBHOOK_SECRET=

# File Storage (Local by default)
UPLOAD_DIR=/app/uploads
AWS_ACCESS_KEY_ID=
AWS_SECRET_ACCESS_KEY=
AWS_S3_BUCKET_NAME=

# Email Service (Mock by default)
SENDGRID_API_KEY=
EMAIL_FROM=noreply@homer.com

# LLM Integration (For natural language search)
EMERGENT_LLM_KEY=

# External APIs (Mock by default)
AQI_API_KEY=
GOOGLE_MAPS_API_KEY=
WALKABILITY_API_KEY=

# CORS
CORS_ORIGINS=http://localhost:3000,http://localhost:3001
```

=================================================================
2. PROJECT STRUCTURE
=================================================================

/app/backend/
â”œâ”€â”€ server.py                       # Main FastAPI application
â”œâ”€â”€ requirements.txt                # Python dependencies
â”œâ”€â”€ .env                           # Environment variables
â”‚
â”œâ”€â”€ config/
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ settings.py                # Configuration management
â”‚   â””â”€â”€ database.py                # Database connection
â”‚
â”œâ”€â”€ models/                         # SQLAlchemy models (database tables)
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ user.py                    # User model
â”‚   â”œâ”€â”€ property.py                # Property model
â”‚   â”œâ”€â”€ chat.py                    # Chat model
â”‚   â”œâ”€â”€ transaction.py             # Transaction model
â”‚   â”œâ”€â”€ shortlist.py               # Shortlist model
â”‚   â””â”€â”€ notification.py            # Notification model
â”‚
â”œâ”€â”€ schemas/                        # Pydantic schemas (request/response)
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ user_schema.py
â”‚   â”œâ”€â”€ property_schema.py
â”‚   â”œâ”€â”€ chat_schema.py
â”‚   â”œâ”€â”€ payment_schema.py
â”‚   â””â”€â”€ common_schema.py
â”‚
â”œâ”€â”€ routes/                         # API endpoints
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ auth.py                    # Authentication routes
â”‚   â”œâ”€â”€ users.py                   # User profile routes
â”‚   â”œâ”€â”€ properties.py              # Property CRUD routes
â”‚   â”œâ”€â”€ search.py                  # Search routes
â”‚   â”œâ”€â”€ chats.py                   # Chat routes
â”‚   â”œâ”€â”€ payments.py                # Payment routes
â”‚   â”œâ”€â”€ shortlists.py              # Shortlist routes
â”‚   â”œâ”€â”€ verification.py            # Verification routes
â”‚   â”œâ”€â”€ reverse_marketplace.py     # Reverse marketplace routes
â”‚   â”œâ”€â”€ analytics.py               # Analytics routes
â”‚   â”œâ”€â”€ lifestyle.py               # Lifestyle data routes
â”‚   â””â”€â”€ notifications.py           # Notification routes
â”‚
â”œâ”€â”€ services/                       # Business logic
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ auth_service.py            # Authentication logic
â”‚   â”œâ”€â”€ property_service.py        # Property operations
â”‚   â”œâ”€â”€ search_service.py          # Search algorithms
â”‚   â”œâ”€â”€ chat_service.py            # Chat operations
â”‚   â”œâ”€â”€ payment_service.py         # Payment processing
â”‚   â”œâ”€â”€ lifestyle_service.py       # Lifestyle data calculation
â”‚   â”œâ”€â”€ verification_service.py    # Verification logic
â”‚   â”œâ”€â”€ storage_service.py         # File upload handling
â”‚   â”œâ”€â”€ email_service.py           # Email sending
â”‚   â”œâ”€â”€ notification_service.py    # Notifications
â”‚   â””â”€â”€ mock_data_service.py       # Mock data generators
â”‚
â”œâ”€â”€ middleware/                     # Custom middleware
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ auth_middleware.py         # JWT verification
â”‚   â”œâ”€â”€ error_handler.py           # Global error handling
â”‚   â””â”€â”€ cors_middleware.py         # CORS configuration
â”‚
â”œâ”€â”€ utils/                          # Utility functions
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ jwt_helper.py              # JWT token functions
â”‚   â”œâ”€â”€ password_helper.py         # Password hashing
â”‚   â”œâ”€â”€ validators.py              # Input validation
â”‚   â”œâ”€â”€ decorators.py              # Custom decorators
â”‚   â””â”€â”€ constants.py               # Constants
â”‚
â””â”€â”€ uploads/                        # Local file storage
    â”œâ”€â”€ verification/
    â”œâ”€â”€ properties/
    â””â”€â”€ documents/

=================================================================
3. DATABASE SETUP & MODELS
=================================================================

The database schema is defined in /app/homer_schema.sql
All models must match this schema exactly.

FILE: /app/backend/config/database.py
--------------------------------------

```python
from sqlalchemy import create_engine
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker
from config.settings import settings

# Create database engine
# Supports both MariaDB (dev) and MySQL (prod)
engine = create_engine(
    settings.DATABASE_URL,
    pool_pre_ping=True,
    pool_size=10,
    max_overflow=20,
    echo=settings.DEBUG  # SQL logging in debug mode
)

# Create session factory
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)

# Base class for models
Base = declarative_base()

# Dependency to get database session
def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()
```

FILE: /app/backend/models/user.py
----------------------------------

```python
from sqlalchemy import Column, String, Boolean, Integer, Enum, Date, TIMESTAMP, Text, JSON
from sqlalchemy.sql import func
from config.database import Base
import enum

class UserType(str, enum.Enum):
    RENTER = "renter"
    OWNER = "owner"
    BOTH = "both"

class SubscriptionTier(str, enum.Enum):
    FREE = "free"
    PREMIUM = "premium"

class VerificationStatus(str, enum.Enum):
    NONE = "none"
    PENDING = "pending"
    VERIFIED = "verified"
    REJECTED = "rejected"

class User(Base):
    __tablename__ = "users"
    
    # Primary identification
    user_id = Column(String(36), primary_key=True, index=True)
    email = Column(String(255), unique=True, nullable=False, index=True)
    phone = Column(String(20), unique=True, nullable=False, index=True)
    password_hash = Column(String(255), nullable=False)
    
    # User type and basic info
    user_type = Column(Enum(UserType), nullable=False, default=UserType.RENTER)
    full_name = Column(String(255))
    profile_photo_url = Column(Text)
    date_of_birth = Column(Date)
    gender = Column(String(20))
    
    # Account status
    is_active = Column(Boolean, default=True)
    created_at = Column(TIMESTAMP, server_default=func.now())
    last_login = Column(TIMESTAMP)
    
    # Renter-specific fields
    subscription_tier = Column(Enum(SubscriptionTier), default=SubscriptionTier.FREE)
    subscription_start = Column(TIMESTAMP)
    subscription_end = Column(TIMESTAMP)
    is_verified_renter = Column(Boolean, default=False)
    renter_verification_status = Column(Enum(VerificationStatus), default=VerificationStatus.NONE)
    renter_verification_documents = Column(JSON)  # Stores document info as JSON
    renter_preferences = Column(JSON)  # Stores preferences as JSON
    employment_info = Column(JSON)  # Stores employment info as JSON
    contacts_used = Column(Integer, default=0)
    profile_visibility = Column(Boolean, default=True)
    
    # Owner-specific fields
    is_verified_owner = Column(Boolean, default=False)
    owner_verification_status = Column(Enum(VerificationStatus), default=VerificationStatus.NONE)
```

FILE: /app/backend/models/property.py
--------------------------------------

```python
from sqlalchemy import Column, String, Text, Enum, DECIMAL, TIMESTAMP, Boolean, JSON, ForeignKey
from sqlalchemy.sql import func
from config.database import Base
import enum

class PropertyType(str, enum.Enum):
    APARTMENT = "apartment"
    VILLA = "villa"
    INDEPENDENT_HOUSE = "independent_house"
    PG = "pg"

class BHKType(str, enum.Enum):
    ONE_BHK = "1BHK"
    TWO_BHK = "2BHK"
    THREE_BHK = "3BHK"
    FOUR_PLUS_BHK = "4BHK+"

class PropertyStatus(str, enum.Enum):
    ACTIVE = "active"
    INACTIVE = "inactive"
    RENTED = "rented"
    DELETED = "deleted"

class VerificationTier(str, enum.Enum):
    FREE = "free"
    VERIFIED = "verified"

class Property(Base):
    __tablename__ = "properties"
    
    # Primary identification
    property_id = Column(String(36), primary_key=True, index=True)
    owner_id = Column(String(36), ForeignKey('users.user_id', ondelete='CASCADE'), nullable=False, index=True)
    
    # Basic information
    title = Column(String(255), nullable=False)
    description = Column(Text)
    property_type = Column(String(50))
    bhk_type = Column(String(20))
    
    # Pricing
    rent = Column(DECIMAL(10, 2), nullable=False, index=True)
    security_deposit = Column(DECIMAL(10, 2))
    maintenance_charges = Column(DECIMAL(10, 2), default=0)
    
    # Location (JSON column)
    location = Column(JSON, nullable=False)
    # Structure: {address, city, state, pincode, latitude, longitude, locality, landmarks}
    
    # Property details (JSON column)
    details = Column(JSON)
    # Structure: {carpet_area, total_floors, floor_number, furnishing, parking, amenities, 
    #            bathrooms, balconies, facing, age_of_property, available_from, 
    #            preferred_tenants, pets_allowed, vegetarian_only}
    
    # Media
    images = Column(JSON)  # Array of image URLs
    video_url = Column(String(500))
    virtual_tour_url = Column(String(500))
    
    # Verification and trust
    is_verified = Column(Boolean, default=False, index=True)
    verification_tier = Column(Enum(VerificationTier), default=VerificationTier.FREE)
    verification_date = Column(TIMESTAMP)
    verification_documents = Column(JSON)
    verification_fee_paid = Column(Boolean, default=False)
    payment_id = Column(String(255))
    
    # Lifestyle data (Premium feature)
    lifestyle_data = Column(JSON)
    # Structure: {aqi_score, noise_level, walkability_score, nearby_parks, nearby_hospitals,
    #            nearby_schools, nearby_malls, public_transport_score, safety_score, 
    #            calculated_at, is_mock}
    
    # Analytics
    analytics = Column(JSON)
    # Structure: {total_views, premium_views, total_contacts, shortlisted_count, 
    #            last_viewed, views_history}
    
    # Status and timestamps
    status = Column(Enum(PropertyStatus), default=PropertyStatus.ACTIVE, index=True)
    created_at = Column(TIMESTAMP, server_default=func.now(), index=True)
    updated_at = Column(TIMESTAMP, server_default=func.now(), onupdate=func.now())
```

FILE: /app/backend/models/chat.py
----------------------------------

```python
from sqlalchemy import Column, String, Enum, TIMESTAMP, JSON, ForeignKey
from sqlalchemy.sql import func
from config.database import Base
import enum

class ChatInitiator(str, enum.Enum):
    RENTER = "renter"
    OWNER = "owner"

class ChatStatus(str, enum.Enum):
    ACTIVE = "active"
    ARCHIVED = "archived"
    BLOCKED = "blocked"

class Chat(Base):
    __tablename__ = "chats"
    
    # Primary identification
    chat_id = Column(String(36), primary_key=True, index=True)
    
    # Participants
    property_id = Column(String(36), ForeignKey('properties.property_id', ondelete='CASCADE'), nullable=False, index=True)
    renter_id = Column(String(36), ForeignKey('users.user_id', ondelete='CASCADE'), nullable=False, index=True)
    owner_id = Column(String(36), ForeignKey('users.user_id', ondelete='CASCADE'), nullable=False, index=True)
    
    # Chat metadata
    initiated_by = Column(Enum(ChatInitiator), nullable=False)
    created_at = Column(TIMESTAMP, server_default=func.now())
    last_message_at = Column(TIMESTAMP, index=True)
    status = Column(Enum(ChatStatus), default=ChatStatus.ACTIVE, index=True)
    
    # Messages (stored as JSON array)
    messages = Column(JSON)
    # Structure: [{message_id, sender_id, sender_type, message, timestamp, is_read, attachments}]
```

FILE: /app/backend/models/transaction.py
-----------------------------------------

```python
from sqlalchemy import Column, String, Enum, DECIMAL, TIMESTAMP, Boolean, JSON, ForeignKey
from sqlalchemy.sql import func
from config.database import Base
import enum

class TransactionType(str, enum.Enum):
    RENTER_SUBSCRIPTION = "renter_subscription"
    PROPERTY_VERIFICATION = "property_verification"

class PaymentStatus(str, enum.Enum):
    PENDING = "pending"
    SUCCESS = "success"
    FAILED = "failed"
    REFUNDED = "refunded"

class Transaction(Base):
    __tablename__ = "transactions"
    
    # Primary identification
    transaction_id = Column(String(36), primary_key=True, index=True)
    user_id = Column(String(36), ForeignKey('users.user_id', ondelete='CASCADE'), nullable=False, index=True)
    
    # Transaction details
    transaction_type = Column(Enum(TransactionType), nullable=False, index=True)
    amount = Column(DECIMAL(10, 2), nullable=False)
    currency = Column(String(3), default='INR')
    
    # Payment gateway details
    payment_gateway = Column(String(50), default='razorpay')
    payment_id = Column(String(255))
    order_id = Column(String(255))
    payment_status = Column(Enum(PaymentStatus), default=PaymentStatus.PENDING, index=True)
    
    # Mock payment indicator
    is_mock = Column(Boolean, default=False)
    
    # Timestamps
    created_at = Column(TIMESTAMP, server_default=func.now(), index=True)
    updated_at = Column(TIMESTAMP, server_default=func.now(), onupdate=func.now())
    
    # Additional metadata
    metadata = Column(JSON)
    # Structure: {subscription_duration, property_id, invoice_url, etc.}
```

FILE: /app/backend/models/shortlist.py
---------------------------------------

```python
from sqlalchemy import Column, String, Text, TIMESTAMP, ForeignKey
from sqlalchemy.sql import func
from config.database import Base

class Shortlist(Base):
    __tablename__ = "shortlists"
    
    # Primary identification
    shortlist_id = Column(String(36), primary_key=True, index=True)
    user_id = Column(String(36), ForeignKey('users.user_id', ondelete='CASCADE'), nullable=False, index=True)
    property_id = Column(String(36), ForeignKey('properties.property_id', ondelete='CASCADE'), nullable=False, index=True)
    
    # Shortlist details
    notes = Column(Text)
    created_at = Column(TIMESTAMP, server_default=func.now(), index=True)
```

FILE: /app/backend/models/notification.py
------------------------------------------

```python
from sqlalchemy import Column, String, Text, Boolean, TIMESTAMP, ForeignKey
from sqlalchemy.sql import func
from config.database import Base

class Notification(Base):
    __tablename__ = "notifications"
    
    # Primary identification
    notification_id = Column(String(36), primary_key=True, index=True)
    user_id = Column(String(36), ForeignKey('users.user_id', ondelete='CASCADE'), nullable=False, index=True)
    
    # Notification details
    type = Column(String(50), nullable=False, index=True)
    title = Column(String(255), nullable=False)
    message = Column(Text, nullable=False)
    action_url = Column(String(500))
    
    # Status
    is_read = Column(Boolean, default=False, index=True)
    created_at = Column(TIMESTAMP, server_default=func.now(), index=True)
```

=================================================================
4. COMPLETE API ENDPOINTS (Matching Frontend Contracts)
=================================================================

All endpoints must match exactly what frontend expects (see frontend_workflow.txt Section 3)

FILE: /app/backend/routes/auth.py
----------------------------------

```python
from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.orm import Session
from typing import Dict
import uuid
from datetime import datetime

from config.database import get_db
from models.user import User
from schemas.user_schema import UserRegister, UserLogin, UserResponse
from utils.password_helper import hash_password, verify_password
from utils.jwt_helper import create_access_token

router = APIRouter(prefix="/api/auth", tags=["Authentication"])

# POST /api/auth/register
@router.post("/register", response_model=Dict)
async def register(user_data: UserRegister, db: Session = Depends(get_db)):
    """
    Register new user
    Expected by frontend: { user_id, token, user_type, user }
    """
    # Check if email or phone already exists
    existing_user = db.query(User).filter(
        (User.email == user_data.email) | (User.phone == user_data.phone)
    ).first()
    
    if existing_user:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Email or phone already registered"
        )
    
    # Create new user
    user_id = str(uuid.uuid4())
    hashed_password = hash_password(user_data.password)
    
    new_user = User(
        user_id=user_id,
        email=user_data.email,
        phone=user_data.phone,
        password_hash=hashed_password,
        user_type=user_data.user_type,
        full_name=user_data.full_name,
        subscription_tier='free' if user_data.user_type == 'renter' else None,
        contacts_used=0,
        is_verified_renter=False,
        is_verified_owner=False,
        created_at=datetime.utcnow()
    )
    
    db.add(new_user)
    db.commit()
    db.refresh(new_user)
    
    # Generate JWT token
    token = create_access_token({"user_id": user_id, "user_type": user_data.user_type})
    
    # Prepare user response (exclude password_hash)
    user_dict = {
        "user_id": new_user.user_id,
        "email": new_user.email,
        "phone": new_user.phone,
        "user_type": new_user.user_type,
        "full_name": new_user.full_name,
        "subscription_tier": new_user.subscription_tier,
        "contacts_used": new_user.contacts_used,
        "is_verified_renter": new_user.is_verified_renter,
        "is_verified_owner": new_user.is_verified_owner,
        "created_at": new_user.created_at.isoformat()
    }
    
    return {
        "user_id": user_id,
        "token": token,
        "user_type": user_data.user_type,
        "user": user_dict
    }

# POST /api/auth/login
@router.post("/login", response_model=Dict)
async def login(credentials: UserLogin, db: Session = Depends(get_db)):
    """
    Login user
    Expected by frontend: { user_id, token, user_type, user }
    """
    # Find user by email or phone
    user = db.query(User).filter(
        (User.email == credentials.email) | (User.phone == credentials.email)
    ).first()
    
    if not user or not verify_password(credentials.password, user.password_hash):
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid credentials"
        )
    
    # Update last login
    user.last_login = datetime.utcnow()
    db.commit()
    
    # Generate JWT token
    token = create_access_token({"user_id": user.user_id, "user_type": user.user_type})
    
    # Prepare user response
    user_dict = {
        "user_id": user.user_id,
        "email": user.email,
        "phone": user.phone,
        "user_type": user.user_type,
        "full_name": user.full_name,
        "subscription_tier": user.subscription_tier,
        "subscription_start": user.subscription_start.isoformat() if user.subscription_start else None,
        "subscription_end": user.subscription_end.isoformat() if user.subscription_end else None,
        "contacts_used": user.contacts_used,
        "is_verified_renter": user.is_verified_renter,
        "is_verified_owner": user.is_verified_owner,
        "renter_preferences": user.renter_preferences,
        "employment_info": user.employment_info,
        "created_at": user.created_at.isoformat()
    }
    
    return {
        "user_id": user.user_id,
        "token": token,
        "user_type": user.user_type,
        "user": user_dict
    }

# POST /api/auth/logout
@router.post("/logout")
async def logout():
    """
    Logout user (frontend handles token removal)
    Expected by frontend: { message }
    """
    return {"message": "Logged out successfully"}

# GET /api/auth/me
@router.get("/me")
async def get_current_user(current_user: User = Depends(get_current_user_dependency)):
    """
    Get current user details
    Expected by frontend: User object
    """
    # Return user without password_hash
    return {
        "user_id": current_user.user_id,
        "email": current_user.email,
        "phone": current_user.phone,
        "user_type": current_user.user_type,
        "full_name": current_user.full_name,
        "subscription_tier": current_user.subscription_tier,
        # ... include all other fields
    }
```

FILE: /app/backend/routes/properties.py
----------------------------------------

```python
from fastapi import APIRouter, Depends, HTTPException, status, UploadFile, File
from sqlalchemy.orm import Session
from typing import Dict, List
import uuid
from datetime import datetime

from config.database import get_db
from models.property import Property
from models.user import User
from schemas.property_schema import PropertyCreate, PropertyUpdate, PropertyResponse
from middleware.auth_middleware import get_current_user
from services.storage_service import upload_files

router = APIRouter(prefix="/api/properties", tags=["Properties"])

# POST /api/properties/create
@router.post("/create")
async def create_property(
    property_data: PropertyCreate,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """
    Create new property
    Expected by frontend: { property_id, property }
    """
    # Check user is owner
    if current_user.user_type not in ['owner', 'both']:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Only owners can create properties"
        )
    
    property_id = str(uuid.uuid4())
    
    new_property = Property(
        property_id=property_id,
        owner_id=current_user.user_id,
        title=property_data.title,
        description=property_data.description,
        property_type=property_data.property_type,
        bhk_type=property_data.bhk_type,
        rent=property_data.rent,
        security_deposit=property_data.security_deposit,
        maintenance_charges=property_data.maintenance_charges,
        location=property_data.location,
        details=property_data.details,
        images=property_data.images or [],
        is_verified=False,
        verification_tier='free',
        status='active',
        analytics={
            "total_views": 0,
            "premium_views": 0,
            "total_contacts": 0,
            "shortlisted_count": 0,
            "last_viewed": None
        },
        created_at=datetime.utcnow()
    )
    
    db.add(new_property)
    db.commit()
    db.refresh(new_property)
    
    return {
        "property_id": property_id,
        "property": convert_property_to_dict(new_property)
    }

# GET /api/properties/search
@router.get("/search")
async def search_properties(
    city: str = None,
    min_price: float = None,
    max_price: float = None,
    bhk_type: str = None,
    location: str = None,
    sort_by: str = None,
    page: int = 1,
    limit: int = 20,
    db: Session = Depends(get_db)
):
    """
    Search properties with filters
    Expected by frontend: { properties: [], total_count, page, has_more }
    """
    query = db.query(Property).filter(Property.status == 'active')
    
    # Apply filters
    if city:
        query = query.filter(Property.location['city'].astext.ilike(f'%{city}%'))
    
    if min_price:
        query = query.filter(Property.rent >= min_price)
    
    if max_price:
        query = query.filter(Property.rent <= max_price)
    
    if bhk_type:
        query = query.filter(Property.bhk_type == bhk_type)
    
    if location:
        query = query.filter(Property.location['locality'].astext.ilike(f'%{location}%'))
    
    # Sort
    if sort_by == 'price_low':
        query = query.order_by(Property.rent.asc())
    elif sort_by == 'price_high':
        query = query.order_by(Property.rent.desc())
    elif sort_by == 'recent':
        query = query.order_by(Property.created_at.desc())
    else:
        # Default: verified first, then by date
        query = query.order_by(Property.is_verified.desc(), Property.created_at.desc())
    
    # Get total count
    total_count = query.count()
    
    # Pagination
    offset = (page - 1) * limit
    properties = query.offset(offset).limit(limit).all()
    
    # Convert to dict
    properties_list = [convert_property_to_dict(p) for p in properties]
    
    return {
        "properties": properties_list,
        "total_count": total_count,
        "page": page,
        "has_more": offset + limit < total_count
    }

# GET /api/properties/lifestyle-search
@router.get("/lifestyle-search")
async def lifestyle_search(
    max_aqi: int = None,
    max_noise: int = None,
    min_walkability: int = None,
    near_parks: bool = None,
    budget: float = None,
    bhk: str = None,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """
    Lifestyle search (premium only)
    Expected by frontend: { properties: [], total_count }
    """
    # Check if premium
    if current_user.subscription_tier != 'premium':
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Lifestyle search is only available for premium users"
        )
    
    # Only verified properties with lifestyle data
    query = db.query(Property).filter(
        Property.status == 'active',
        Property.is_verified == True,
        Property.lifestyle_data.isnot(None)
    )
    
    # Apply lifestyle filters
    if max_aqi:
        query = query.filter(Property.lifestyle_data['aqi_score'].astext.cast(Integer) <= max_aqi)
    
    if max_noise:
        query = query.filter(Property.lifestyle_data['noise_level'].astext.cast(Integer) <= max_noise)
    
    if min_walkability:
        query = query.filter(Property.lifestyle_data['walkability_score'].astext.cast(Integer) >= min_walkability)
    
    # Apply standard filters
    if budget:
        query = query.filter(Property.rent <= budget)
    
    if bhk:
        query = query.filter(Property.bhk_type == bhk)
    
    properties = query.all()
    properties_list = [convert_property_to_dict(p) for p in properties]
    
    return {
        "properties": properties_list,
        "total_count": len(properties_list)
    }

# GET /api/properties/:property_id
@router.get("/{property_id}")
async def get_property_detail(
    property_id: str,
    db: Session = Depends(get_db)
):
    """
    Get property details
    Expected by frontend: Property object
    """
    property = db.query(Property).filter(Property.property_id == property_id).first()
    
    if not property:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Property not found"
        )
    
    # Increment view count
    analytics = property.analytics or {}
    analytics['total_views'] = analytics.get('total_views', 0) + 1
    analytics['last_viewed'] = datetime.utcnow().isoformat()
    property.analytics = analytics
    
    db.commit()
    
    return convert_property_to_dict(property)

# PUT /api/properties/:property_id
@router.put("/{property_id}")
async def update_property(
    property_id: str,
    property_data: PropertyUpdate,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """
    Update property
    Expected by frontend: Updated property object
    """
    property = db.query(Property).filter(Property.property_id == property_id).first()
    
    if not property:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Property not found")
    
    # Check ownership
    if property.owner_id != current_user.user_id:
        raise HTTPException(status_code=status.HTTP_403_FORBIDDEN, detail="Not authorized")
    
    # Update fields
    for field, value in property_data.dict(exclude_unset=True).items():
        setattr(property, field, value)
    
    property.updated_at = datetime.utcnow()
    
    db.commit()
    db.refresh(property)
    
    return convert_property_to_dict(property)

# DELETE /api/properties/:property_id
@router.delete("/{property_id}")
async def delete_property(
    property_id: str,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """
    Delete property
    Expected by frontend: { message }
    """
    property = db.query(Property).filter(Property.property_id == property_id).first()
    
    if not property:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Property not found")
    
    # Check ownership
    if property.owner_id != current_user.user_id:
        raise HTTPException(status_code=status.HTTP_403_FORBIDDEN, detail="Not authorized")
    
    # Soft delete (update status)
    property.status = 'deleted'
    db.commit()
    
    return {"message": "Property deleted successfully"}

# GET /api/properties/my-properties
@router.get("/my-properties")
async def get_my_properties(
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """
    Get owner's properties
    Expected by frontend: List of properties
    """
    properties = db.query(Property).filter(
        Property.owner_id == current_user.user_id,
        Property.status != 'deleted'
    ).all()
    
    properties_list = [convert_property_to_dict(p) for p in properties]
    
    return properties_list

# POST /api/properties/:property_id/upload-images
@router.post("/{property_id}/upload-images")
async def upload_property_images(
    property_id: str,
    files: List[UploadFile] = File(...),
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """
    Upload property images
    Expected by frontend: { image_urls: [] }
    """
    property = db.query(Property).filter(Property.property_id == property_id).first()
    
    if not property:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Property not found")
    
    # Check ownership
    if property.owner_id != current_user.user_id:
        raise HTTPException(status_code=status.HTTP_403_FORBIDDEN, detail="Not authorized")
    
    # Upload files
    image_urls = await upload_files(files, f"properties/{property_id}")
    
    # Add to property images
    current_images = property.images or []
    property.images = current_images + image_urls
    
    db.commit()
    
    return {"image_urls": image_urls}

# GET /api/properties/:property_id/analytics
@router.get("/{property_id}/analytics")
async def get_property_analytics(
    property_id: str,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """
    Get property analytics
    Expected by frontend: Analytics object
    """
    property = db.query(Property).filter(Property.property_id == property_id).first()
    
    if not property:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Property not found")
    
    # Check ownership
    if property.owner_id != current_user.user_id:
        raise HTTPException(status_code=status.HTTP_403_FORBIDDEN, detail="Not authorized")
    
    return property.analytics or {}

# Helper function
def convert_property_to_dict(property: Property) -> dict:
    """Convert Property model to dict for JSON response"""
    return {
        "property_id": property.property_id,
        "owner_id": property.owner_id,
        "title": property.title,
        "description": property.description,
        "property_type": property.property_type,
        "bhk_type": property.bhk_type,
        "rent": float(property.rent),
        "security_deposit": float(property.security_deposit) if property.security_deposit else None,
        "maintenance_charges": float(property.maintenance_charges) if property.maintenance_charges else None,
        "location": property.location,
        "details": property.details,
        "images": property.images,
        "video_url": property.video_url,
        "virtual_tour_url": property.virtual_tour_url,
        "is_verified": property.is_verified,
        "verification_tier": property.verification_tier,
        "verification_date": property.verification_date.isoformat() if property.verification_date else None,
        "lifestyle_data": property.lifestyle_data,
        "analytics": property.analytics,
        "status": property.status,
        "created_at": property.created_at.isoformat(),
        "updated_at": property.updated_at.isoformat() if property.updated_at else None
    }
```

FILE: /app/backend/routes/chats.py
-----------------------------------

```python
from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.orm import Session
from typing import Dict, List
import uuid
from datetime import datetime

from config.database import get_db
from models.chat import Chat
from models.user import User
from models.property import Property
from middleware.auth_middleware import get_current_user

router = APIRouter(prefix="/api/chats", tags=["Chats"])

# POST /api/chats/initiate
@router.post("/initiate")
async def initiate_chat(
    property_id: str,
    initial_message: str,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """
    Initiate chat with property owner
    Expected by frontend: { chat_id }
    """
    # Check if user is renter
    if current_user.user_type not in ['renter', 'both']:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Only renters can initiate chats"
        )
    
    # Check contact limit for free tier
    if current_user.subscription_tier == 'free' and current_user.contacts_used >= 5:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Contact limit reached. Upgrade to premium."
        )
    
    # Get property to find owner
    property = db.query(Property).filter(Property.property_id == property_id).first()
    if not property:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Property not found")
    
    # Check if chat already exists
    existing_chat = db.query(Chat).filter(
        Chat.property_id == property_id,
        Chat.renter_id == current_user.user_id
    ).first()
    
    if existing_chat:
        return {"chat_id": existing_chat.chat_id}
    
    # Create new chat
    chat_id = str(uuid.uuid4())
    message_id = str(uuid.uuid4())
    
    new_chat = Chat(
        chat_id=chat_id,
        property_id=property_id,
        renter_id=current_user.user_id,
        owner_id=property.owner_id,
        initiated_by='renter',
        created_at=datetime.utcnow(),
        last_message_at=datetime.utcnow(),
        status='active',
        messages=[{
            "message_id": message_id,
            "sender_id": current_user.user_id,
            "sender_type": "renter",
            "message": initial_message,
            "timestamp": datetime.utcnow().isoformat(),
            "is_read": False,
            "attachments": []
        }]
    )
    
    db.add(new_chat)
    
    # Increment contacts_used for free tier
    if current_user.subscription_tier == 'free':
        current_user.contacts_used += 1
    
    # Increment property analytics
    analytics = property.analytics or {}
    analytics['total_contacts'] = analytics.get('total_contacts', 0) + 1
    property.analytics = analytics
    
    db.commit()
    
    return {"chat_id": chat_id}

# GET /api/chats
@router.get("")
async def get_chats(
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """
    Get all chats for user
    Expected by frontend: List of chats
    """
    chats = db.query(Chat).filter(
        ((Chat.renter_id == current_user.user_id) | (Chat.owner_id == current_user.user_id)),
        Chat.status == 'active'
    ).order_by(Chat.last_message_at.desc()).all()
    
    chats_list = [convert_chat_to_dict(chat) for chat in chats]
    
    return chats_list

# GET /api/chats/:chat_id
@router.get("/{chat_id}")
async def get_chat_detail(
    chat_id: str,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """
    Get chat details
    Expected by frontend: Chat object with messages
    """
    chat = db.query(Chat).filter(Chat.chat_id == chat_id).first()
    
    if not chat:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Chat not found")
    
    # Check access
    if chat.renter_id != current_user.user_id and chat.owner_id != current_user.user_id:
        raise HTTPException(status_code=status.HTTP_403_FORBIDDEN, detail="Not authorized")
    
    # Mark messages as read
    messages = chat.messages or []
    for msg in messages:
        if msg['sender_id'] != current_user.user_id:
            msg['is_read'] = True
    chat.messages = messages
    
    db.commit()
    
    return convert_chat_to_dict(chat)

# POST /api/chats/:chat_id/messages
@router.post("/{chat_id}/messages")
async def send_message(
    chat_id: str,
    message: str,
    attachments: List[str] = [],
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """
    Send message in chat
    Expected by frontend: { message_id }
    """
    chat = db.query(Chat).filter(Chat.chat_id == chat_id).first()
    
    if not chat:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Chat not found")
    
    # Check access
    if chat.renter_id != current_user.user_id and chat.owner_id != current_user.user_id:
        raise HTTPException(status_code=status.HTTP_403_FORBIDDEN, detail="Not authorized")
    
    # Determine sender type
    sender_type = 'renter' if chat.renter_id == current_user.user_id else 'owner'
    
    # Create new message
    message_id = str(uuid.uuid4())
    new_message = {
        "message_id": message_id,
        "sender_id": current_user.user_id,
        "sender_type": sender_type,
        "message": message,
        "timestamp": datetime.utcnow().isoformat(),
        "is_read": False,
        "attachments": attachments
    }
    
    # Add to messages
    messages = chat.messages or []
    messages.append(new_message)
    chat.messages = messages
    chat.last_message_at = datetime.utcnow()
    
    db.commit()
    
    return {"message_id": message_id}

# GET /api/chats/unread-count
@router.get("/unread-count")
async def get_unread_count(
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """
    Get unread messages count
    Expected by frontend: { unread_count }
    """
    chats = db.query(Chat).filter(
        ((Chat.renter_id == current_user.user_id) | (Chat.owner_id == current_user.user_id)),
        Chat.status == 'active'
    ).all()
    
    unread_count = 0
    for chat in chats:
        messages = chat.messages or []
        for msg in messages:
            if msg['sender_id'] != current_user.user_id and not msg.get('is_read', False):
                unread_count += 1
    
    return {"unread_count": unread_count}

def convert_chat_to_dict(chat: Chat) -> dict:
    """Convert Chat model to dict"""
    return {
        "chat_id": chat.chat_id,
        "property_id": chat.property_id,
        "renter_id": chat.renter_id,
        "owner_id": chat.owner_id,
        "initiated_by": chat.initiated_by,
        "created_at": chat.created_at.isoformat(),
        "last_message_at": chat.last_message_at.isoformat() if chat.last_message_at else None,
        "status": chat.status,
        "messages": chat.messages or []
    }
```

FILE: /app/backend/routes/payments.py
--------------------------------------

```python
from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.orm import Session
from typing import Dict
import uuid
from datetime import datetime, timedelta
import os

from config.database import get_db
from models.transaction import Transaction
from models.user import User
from models.property import Property
from middleware.auth_middleware import get_current_user

router = APIRouter(prefix="/api/payments", tags=["Payments"])

# POST /api/payments/create-order
@router.post("/create-order")
async def create_payment_order(
    type: str,
    metadata: dict = {},
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """
    Create payment order
    Expected by frontend: { order_id, amount, currency, is_mock, payment_gateway_data }
    """
    # Check if mock mode
    razorpay_key = os.getenv('RAZORPAY_KEY_ID', '')
    is_mock = not razorpay_key or razorpay_key == ''
    
    # Determine amount
    amount = 750 if type == 'renter_subscription' else 2000
    order_id = f"{'mock_order' if is_mock else 'rzp_order'}_{uuid.uuid4().hex[:12]}"
    
    if is_mock:
        # Mock payment
        return {
            "order_id": order_id,
            "amount": amount,
            "currency": "INR",
            "is_mock": True,
            "payment_gateway_data": {
                "key_id": "mock_razorpay_key",
                "name": "Homer",
                "description": "Premium Subscription" if type == 'renter_subscription' else "Property Verification"
            }
        }
    else:
        # Real Razorpay integration
        import razorpay
        client = razorpay.Client(auth=(os.getenv('RAZORPAY_KEY_ID'), os.getenv('RAZORPAY_KEY_SECRET')))
        
        order = client.order.create({
            "amount": int(amount * 100),  # Razorpay amount in paise
            "currency": "INR",
            "receipt": order_id
        })
        
        return {
            "order_id": order['id'],
            "amount": amount,
            "currency": "INR",
            "is_mock": False,
            "payment_gateway_data": {
                "key_id": os.getenv('RAZORPAY_KEY_ID'),
                "name": "Homer",
                "description": "Premium Subscription" if type == 'renter_subscription' else "Property Verification"
            }
        }

# POST /api/payments/verify
@router.post("/verify")
async def verify_payment(
    payment_id: str,
    order_id: str,
    signature: str = None,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """
    Verify payment
    Expected by frontend: { success, transaction_id }
    """
    is_mock = order_id.startswith('mock_order')
    
    if is_mock:
        # Mock payment verification (always succeeds)
        transaction_id = str(uuid.uuid4())
        transaction_type = 'renter_subscription' if 'subscription' in order_id else 'property_verification'
        amount = 750 if transaction_type == 'renter_subscription' else 2000
        
        # Create transaction record
        transaction = Transaction(
            transaction_id=transaction_id,
            user_id=current_user.user_id,
            transaction_type=transaction_type,
            amount=amount,
            currency='INR',
            payment_gateway='razorpay',
            payment_id=payment_id,
            order_id=order_id,
            payment_status='success',
            is_mock=True,
            created_at=datetime.utcnow(),
            metadata={}
        )
        
        db.add(transaction)
        
        # Update user if subscription
        if transaction_type == 'renter_subscription':
            current_user.subscription_tier = 'premium'
            current_user.subscription_start = datetime.utcnow()
            current_user.subscription_end = datetime.utcnow() + timedelta(days=90)
            current_user.contacts_used = 0
        
        db.commit()
        
        return {
            "success": True,
            "transaction_id": transaction_id
        }
    else:
        # Real Razorpay verification
        import razorpay
        client = razorpay.Client(auth=(os.getenv('RAZORPAY_KEY_ID'), os.getenv('RAZORPAY_KEY_SECRET')))
        
        try:
            client.utility.verify_payment_signature({
                'razorpay_order_id': order_id,
                'razorpay_payment_id': payment_id,
                'razorpay_signature': signature
            })
            
            # Payment verified, create transaction and update user
            # ... similar to mock flow
            
            return {
                "success": True,
                "transaction_id": transaction_id
            }
        except:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="Payment verification failed"
            )

# GET /api/payments/history
@router.get("/history")
async def get_payment_history(
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """
    Get payment history
    Expected by frontend: List of transactions
    """
    transactions = db.query(Transaction).filter(
        Transaction.user_id == current_user.user_id
    ).order_by(Transaction.created_at.desc()).all()
    
    transactions_list = [convert_transaction_to_dict(t) for t in transactions]
    
    return transactions_list

def convert_transaction_to_dict(transaction: Transaction) -> dict:
    """Convert Transaction model to dict"""
    return {
        "transaction_id": transaction.transaction_id,
        "user_id": transaction.user_id,
        "transaction_type": transaction.transaction_type,
        "amount": float(transaction.amount),
        "currency": transaction.currency,
        "payment_gateway": transaction.payment_gateway,
        "payment_id": transaction.payment_id,
        "order_id": transaction.order_id,
        "payment_status": transaction.payment_status,
        "is_mock": transaction.is_mock,
        "created_at": transaction.created_at.isoformat(),
        "metadata": transaction.metadata
    }
```

=================================================================
4B. STORAGE SERVICE & FILE UPLOAD
=================================================================

âš¡ CRITICAL: FILES UPLOAD IMMEDIATELY (NOT ON FORM SUBMIT)
-----------------------------------------------------------

FLOW OVERVIEW:
1. User selects file â†’ Frontend IMMEDIATELY calls uploadDocument()
2. Backend saves file to disk â†’ Returns URL
3. Frontend stores URL in form state (NOT the file)
4. User fills other form fields
5. User clicks "Submit" â†’ Frontend sends URLs (NOT files)
6. Backend stores URLs in MySQL JSON columns

KEY PRINCIPLE:
- Files go to DISK immediately when selected
- URLs go to MySQL when form submitted
- Submit button NEVER sends files (only URLs)
- Admin downloads from DISK using URLs from MySQL

WHY THIS APPROACH?
âœ… Better UX: No waiting during submit (files already uploaded)
âœ… Progress feedback: Users see upload progress immediately
âœ… Retry logic: Can retry individual file uploads
âœ… Validation: File validation happens before form submit
âœ… MySQL efficiency: Store URLs (few bytes) not files (megabytes)
âœ… Scalability: Easy to switch to S3/cloud storage

FILE: /app/backend/services/storage_service.py
------------------------------------------------

```python
import os
import uuid
import shutil
from typing import List
from fastapi import UploadFile, HTTPException
from datetime import datetime
import aiofiles

# Configuration
UPLOAD_BASE_DIR = os.getenv('UPLOAD_DIR', '/app/uploads')
ALLOWED_EXTENSIONS = {'.pdf', '.jpg', '.jpeg', '.png', '.doc', '.docx'}
MAX_FILE_SIZE = 10 * 1024 * 1024  # 10MB

def get_file_extension(filename: str) -> str:
    """Get file extension"""
    return os.path.splitext(filename)[1].lower()

def validate_file(file: UploadFile) -> None:
    """Validate file type and size"""
    ext = get_file_extension(file.filename)
    if ext not in ALLOWED_EXTENSIONS:
        raise HTTPException(
            status_code=400,
            detail=f"File type not allowed. Allowed: {', '.join(ALLOWED_EXTENSIONS)}"
        )

async def save_file(file: UploadFile, subdirectory: str) -> dict:
    """
    Save uploaded file to local storage
    
    Args:
        file: UploadFile object
        subdirectory: Subdirectory (e.g., "verification/user_123")
    
    Returns:
        dict with file metadata (file_name, file_url, file_size, etc.)
    """
    try:
        validate_file(file)
        
        # Create directory
        upload_dir = os.path.join(UPLOAD_BASE_DIR, subdirectory)
        os.makedirs(upload_dir, exist_ok=True)
        
        # Generate unique filename
        file_ext = get_file_extension(file.filename)
        unique_filename = f"{uuid.uuid4().hex[:8]}_{int(datetime.now().timestamp())}{file_ext}"
        file_path = os.path.join(upload_dir, unique_filename)
        
        # Save file
        async with aiofiles.open(file_path, 'wb') as f:
            content = await file.read()
            
            if len(content) > MAX_FILE_SIZE:
                raise HTTPException(
                    status_code=400,
                    detail=f"File too large. Max: {MAX_FILE_SIZE / (1024*1024)}MB"
                )
            
            await f.write(content)
        
        # Return metadata
        file_url = f"/uploads/{subdirectory}/{unique_filename}"
        
        return {
            "file_name": file.filename,
            "file_url": file_url,
            "file_size": len(content),
            "file_type": file.content_type,
            "uploaded_at": datetime.utcnow().isoformat()
        }
    
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(
            status_code=500,
            detail=f"Failed to save file: {str(e)}"
        )

async def upload_files(files: List[UploadFile], subdirectory: str) -> List[str]:
    """Upload multiple files (for property images)"""
    file_urls = []
    for file in files:
        file_metadata = await save_file(file, subdirectory)
        file_urls.append(file_metadata['file_url'])
    return file_urls

def delete_file(file_url: str) -> bool:
    """Delete file from storage"""
    try:
        file_path = file_url.replace('/uploads/', '')
        full_path = os.path.join(UPLOAD_BASE_DIR, file_path)
        if os.path.exists(full_path):
            os.remove(full_path)
            return True
        return False
    except Exception as e:
        print(f"Error deleting file: {e}")
        return False
```

=================================================================
4C. VERIFICATION ROUTES (COMPLETE)
=================================================================

ðŸ”„ TWO-STEP VERIFICATION PROCESS
---------------------------------

STEP 1: UPLOAD FILES IMMEDIATELY (ONE AT A TIME)
Endpoint: POST /api/verification/upload-document
- Called when user selects each file (not on submit)
- Receives: FormData with file
- Saves: File to /app/uploads/verification/{user_id}/
- Returns: File metadata with URL
- Frontend: Stores URL in form state

STEP 2: SUBMIT VERIFICATION (URLS ONLY)
Endpoint: POST /api/verification/renter/submit
- Called when user clicks "Submit Verification" button
- Receives: JSON with file URLs (from step 1) + employment details
- NO FILES in this request (only URLs)
- Stores: URLs in MySQL JSON columns
- Updates: verification_status = 'pending'

ADMIN WORKFLOW:
1. GET /api/verification/admin/pending â†’ Returns URLs from MySQL
2. GET /uploads/verification/{user_id}/{filename} â†’ Serves file from disk
3. POST /api/verification/admin/approve/{id} â†’ Updates MySQL status

FILE: /app/backend/routes/verification.py
------------------------------------------

```python
from fastapi import APIRouter, Depends, HTTPException, status, UploadFile, File, Form
from sqlalchemy.orm import Session
from typing import Optional
from datetime import datetime

from config.database import get_db
from models.user import User
from models.property import Property
from middleware.auth_middleware import get_current_user
from services.storage_service import save_file

router = APIRouter(prefix="/api/verification", tags=["Verification"])

# =================================================================
# DOCUMENT UPLOAD ENDPOINT (CRITICAL - CALLED BY FRONTEND)
# =================================================================

@router.post("/upload-document")
async def upload_verification_document(
    document: UploadFile = File(...),
    document_type: str = Form(...),
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """
    Upload verification document (ID proof, income proof, etc.)
    
    Frontend expects:
    - FormData with 'document' (file) and 'document_type' (string)
    
    Returns:
    - {success: true, data: {file_name, file_url, file_size, uploaded_at}}
    
    Called by: frontend/src/services/verificationService.js line 370-387
    """
    try:
        # Save file in user-specific directory
        subdirectory = f"verification/{current_user.user_id}"
        file_metadata = await save_file(document, subdirectory)
        
        return {
            "success": True,
            "data": file_metadata
        }
    
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Failed to upload document: {str(e)}"
        )

# =================================================================
# RENTER VERIFICATION SUBMISSION
# =================================================================

@router.post("/renter/submit")
async def submit_renter_verification(
    verification_data: dict,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """
    Submit renter verification with documents and employment details
    
    Expected by frontend (verificationService.js line 77-120):
    {
        "documents": {
            "id_proof": {
                "type": "aadhaar",
                "file_name": "...",
                "file_url": "/uploads/verification/...",
                "file_size": 123456,
                "uploaded_at": "..."
            },
            "income_proof": {...}
        },
        "employment_details": {
            "company_name": "...",
            "designation": "...",
            "employment_type": "salaried",
            "annual_income": 1500000,
            "years_of_experience": 5
        }
    }
    
    Stores in MySQL:
    - users.renter_verification_documents (JSON column)
    - users.employment_info (JSON column)
    - users.renter_verification_status = 'pending'
    """
    try:
        # Update user's verification data in MySQL
        current_user.renter_verification_documents = verification_data.get('documents')
        current_user.employment_info = verification_data.get('employment_details')
        current_user.renter_verification_status = 'pending'
        
        db.commit()
        
        return {
            "success": True,
            "message": "Verification request submitted successfully",
            "verification_id": f"renter_{current_user.user_id}",
            "status": "pending"
        }
    
    except Exception as e:
        db.rollback()
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Failed to submit verification: {str(e)}"
        )

# =================================================================
# PROPERTY VERIFICATION SUBMISSION
# =================================================================

@router.post("/property/submit")
async def submit_property_verification(
    verification_data: dict,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """
    Submit property verification with documents
    
    Stores in MySQL:
    - properties.verification_documents (JSON column)
    - properties.verification_tier = 'pending'
    """
    try:
        property_id = verification_data.get('property_id')
        
        # Get property
        property_obj = db.query(Property).filter(
            Property.property_id == property_id,
            Property.owner_id == current_user.user_id
        ).first()
        
        if not property_obj:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="Property not found or not authorized"
            )
        
        # Update property verification in MySQL
        property_obj.verification_documents = verification_data.get('documents')
        property_obj.verification_tier = 'pending'
        property_obj.verification_fee_paid = verification_data.get('payment_status') == 'success'
        property_obj.payment_id = verification_data.get('payment_id')
        
        db.commit()
        
        return {
            "success": True,
            "message": "Property verification request submitted successfully",
            "verification_id": f"property_{property_id}",
            "status": "pending"
        }
    
    except HTTPException:
        raise
    except Exception as e:
        db.rollback()
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Failed to submit verification: {str(e)}"
        )

# =================================================================
# GET MY VERIFICATION STATUS
# =================================================================

@router.get("/my-status")
async def get_my_verification_status(
    type: str = "renter",
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """
    Get current user's verification status
    
    Called by: frontend/src/pages/renter/VerificationUpload.js line 37
    
    Returns data from MySQL users table
    """
    if type == "renter":
        return {
            "status": current_user.renter_verification_status or "none",
            "is_verified": current_user.is_verified_renter or False,
            "verification": {
                "documents": current_user.renter_verification_documents,
                "employment_details": current_user.employment_info,
                "submitted_at": None,
                "reviewed_at": None,
                "rejection_reason": None
            } if current_user.renter_verification_status == "pending" else None
        }
    else:
        return {
            "status": current_user.owner_verification_status or "none",
            "is_verified": current_user.is_verified_owner or False
        }

# =================================================================
# ADMIN: GET PENDING VERIFICATIONS
# =================================================================

@router.get("/admin/pending")
async def get_pending_verifications(
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """
    Get all pending verification requests (admin only)
    
    Called by: frontend/src/pages/admin/VerificationReview.js line 26
    
    Returns:
    - List of pending renter and property verifications
    - Includes user details and document URLs from MySQL
    
    Admin can then view documents via secure file serving endpoint
    """
    # Check admin permission
    if not current_user.is_admin:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Not authorized"
        )
    
    verifications = []
    
    # Get pending renter verifications from MySQL
    pending_renters = db.query(User).filter(
        User.renter_verification_status == 'pending'
    ).all()
    
    for user in pending_renters:
        verifications.append({
            "verification_id": f"renter_{user.user_id}",
            "verification_type": "renter",
            "user_id": user.user_id,
            "user_name": user.full_name,
            "user_email": user.email,
            "documents": user.renter_verification_documents,  # File URLs from JSON
            "employment_details": user.employment_info,
            "submitted_at": user.created_at.isoformat() if user.created_at else None,
            "status": "pending"
        })
    
    # Get pending property verifications from MySQL
    pending_properties = db.query(Property).filter(
        Property.verification_tier == 'pending'
    ).all()
    
    for prop in pending_properties:
        owner = db.query(User).filter(User.user_id == prop.owner_id).first()
        verifications.append({
            "verification_id": f"property_{prop.property_id}",
            "verification_type": "property",
            "property_id": prop.property_id,
            "property_title": prop.title,
            "owner_id": prop.owner_id,
            "owner_name": owner.full_name if owner else None,
            "owner_email": owner.email if owner else None,
            "documents": prop.verification_documents,  # File URLs from JSON
            "payment_status": "success" if prop.verification_fee_paid else "pending",
            "submitted_at": prop.created_at.isoformat() if prop.created_at else None,
            "status": "pending"
        })
    
    return verifications

# =================================================================
# ADMIN: APPROVE VERIFICATION
# =================================================================

@router.post("/admin/approve/{verification_id}")
async def approve_verification(
    verification_id: str,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """
    Approve verification request (admin only)
    
    Called by: frontend/src/pages/admin/VerificationReview.js line 47
    
    Updates MySQL database:
    - For renter: users.is_verified_renter = true
    - For property: properties.is_verified = true
    """
    if not current_user.is_admin:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Not authorized"
        )
    
    try:
        # Parse verification_id format: "renter_user_123" or "property_prop_456"
        parts = verification_id.split('_')
        verification_type = parts[0]
        entity_id = '_'.join(parts[1:])
        
        if verification_type == "renter":
            user = db.query(User).filter(User.user_id == entity_id).first()
            if not user:
                raise HTTPException(status_code=404, detail="User not found")
            
            # Update MySQL
            user.is_verified_renter = True
            user.renter_verification_status = 'verified'
            
        elif verification_type == "property":
            prop = db.query(Property).filter(Property.property_id == entity_id).first()
            if not prop:
                raise HTTPException(status_code=404, detail="Property not found")
            
            # Update MySQL
            prop.is_verified = True
            prop.verification_tier = 'verified'
            prop.verification_date = datetime.utcnow()
            
            # Also mark owner as verified
            owner = db.query(User).filter(User.user_id == prop.owner_id).first()
            if owner:
                owner.is_verified_owner = True
                owner.owner_verification_status = 'verified'
        
        db.commit()
        
        return {
            "success": True,
            "message": "Verification approved successfully"
        }
    
    except HTTPException:
        raise
    except Exception as e:
        db.rollback()
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Failed to approve verification: {str(e)}"
        )

# =================================================================
# ADMIN: REJECT VERIFICATION
# =================================================================

@router.post("/admin/reject/{verification_id}")
async def reject_verification(
    verification_id: str,
    reason_data: dict,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """
    Reject verification request (admin only)
    
    Called by: frontend/src/pages/admin/VerificationReview.js line 72
    
    Expected body: {"reason": "Reason for rejection"}
    
    Updates MySQL database verification status to 'rejected'
    """
    if not current_user.is_admin:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Not authorized"
        )
    
    try:
        reason = reason_data.get('reason')
        
        # Parse verification_id
        parts = verification_id.split('_')
        verification_type = parts[0]
        entity_id = '_'.join(parts[1:])
        
        if verification_type == "renter":
            user = db.query(User).filter(User.user_id == entity_id).first()
            if not user:
                raise HTTPException(status_code=404, detail="User not found")
            
            # Update MySQL
            user.renter_verification_status = 'rejected'
            # TODO: Store rejection reason in future schema update
            
        elif verification_type == "property":
            prop = db.query(Property).filter(Property.property_id == entity_id).first()
            if not prop:
                raise HTTPException(status_code=404, detail="Property not found")
            
            # Update MySQL
            prop.verification_tier = 'free'
        
        db.commit()
        
        return {
            "success": True,
            "message": "Verification rejected"
        }
    
    except HTTPException:
        raise
    except Exception as e:
        db.rollback()
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Failed to reject verification: {str(e)}"
        )
```

=================================================================
4D. COMPLETE FILE UPLOAD WORKFLOW (VISUAL DIAGRAM)
=================================================================

ðŸ“‹ RENTER VERIFICATION FLOW:

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ FRONTEND                     BACKEND                  STORAGE   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                  â”‚
â”‚ 1. User selects ID proof                                        â”‚
â”‚    â†“                                                             â”‚
â”‚ 2. uploadDocument(file, 'id_proof')                             â”‚
â”‚    â†’ POST /api/verification/upload-document                     â”‚
â”‚    â†’ FormData: { document: [FILE], document_type: 'id_proof' } â”‚
â”‚                              â†“                                   â”‚
â”‚                         Validate file                            â”‚
â”‚                         Save to disk â”€â”€â”€â”€â”€â”€â”€â”€â†’ /app/uploads/    â”‚
â”‚                              â†“                  verification/    â”‚
â”‚                         Generate URL            user_123/       â”‚
â”‚                              â†“                  abc_123.pdf     â”‚
â”‚    â† Returns: { file_url: "/uploads/..." }                      â”‚
â”‚    â†“                                                             â”‚
â”‚ 3. Store URL in state                                           â”‚
â”‚    documents.id_proof = { file_url: "...", file_name: "..." }  â”‚
â”‚                                                                  â”‚
â”‚ 4. User selects income proof                                    â”‚
â”‚    â†“                                                             â”‚
â”‚ 5. uploadDocument(file, 'income_proof')                         â”‚
â”‚    â†’ POST /api/verification/upload-document                     â”‚
â”‚                              â†“                                   â”‚
â”‚                         Save to disk â”€â”€â”€â”€â”€â”€â”€â”€â†’ /app/uploads/    â”‚
â”‚                              â†“                  verification/    â”‚
â”‚    â† Returns: { file_url: "..." }              user_123/       â”‚
â”‚    â†“                                            def_456.pdf     â”‚
â”‚ 6. Store URL in state                                           â”‚
â”‚    documents.income_proof = { file_url: "..." }                â”‚
â”‚                                                                  â”‚
â”‚ 7. User fills employment form                                   â”‚
â”‚                                                                  â”‚
â”‚ 8. User clicks "Submit Verification"                            â”‚
â”‚    â†“                                                             â”‚
â”‚ 9. submitRenterVerification({                                   â”‚
â”‚      documents: { id_proof: {...}, income_proof: {...} },      â”‚
â”‚      employment_details: {...}                                  â”‚
â”‚    })                                                           â”‚
â”‚    â†’ POST /api/verification/renter/submit                       â”‚
â”‚    â†’ JSON: { documents: {...}, employment_details: {...} }     â”‚
â”‚    â†’ NO FILES, only URLs                                        â”‚
â”‚                              â†“                                   â”‚
â”‚                         Store URLs in MySQL                     â”‚
â”‚                         users.renter_verification_documents =   â”‚
â”‚                         { id_proof: { file_url: "..." } }       â”‚
â”‚                              â†“                                   â”‚
â”‚                         Set status = 'pending'                  â”‚
â”‚                              â†“                                   â”‚
â”‚    â† Returns: { success: true, status: 'pending' }             â”‚
â”‚                                                                  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ ADMIN REVIEW FLOW:                                              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                  â”‚
â”‚ 1. Admin views pending verifications                            â”‚
â”‚    â†’ GET /api/verification/admin/pending                        â”‚
â”‚                              â†“                                   â”‚
â”‚                         Query MySQL                             â”‚
â”‚                         SELECT renter_verification_documents    â”‚
â”‚                         FROM users WHERE status = 'pending'     â”‚
â”‚                              â†“                                   â”‚
â”‚    â† Returns: [{                                                â”‚
â”‚         user_id: "user_123",                                    â”‚
â”‚         documents: {                                            â”‚
â”‚           id_proof: {                                           â”‚
â”‚             file_url: "/uploads/verification/user_123/abc.pdf" â”‚
â”‚           }                                                     â”‚
â”‚         }                                                       â”‚
â”‚       }]                                                        â”‚
â”‚                                                                  â”‚
â”‚ 2. Admin clicks document link                                   â”‚
â”‚    â†’ GET /uploads/verification/user_123/abc_123.pdf            â”‚
â”‚                              â†“                                   â”‚
â”‚                         Check authorization                     â”‚
â”‚                         (admin or owner only)                   â”‚
â”‚                              â†“                                   â”‚
â”‚                         Read file from disk â†â”€â”€â”€â”€ /app/uploads/ â”‚
â”‚                              â†“                     verification/ â”‚
â”‚                         FileResponse               user_123/    â”‚
â”‚                              â†“                     abc_123.pdf  â”‚
â”‚    â† Returns: [PDF FILE DATA]                                   â”‚
â”‚                                                                  â”‚
â”‚ 3. Admin approves                                               â”‚
â”‚    â†’ POST /api/verification/admin/approve/renter_user_123      â”‚
â”‚                              â†“                                   â”‚
â”‚                         Update MySQL                            â”‚
â”‚                         SET is_verified_renter = true           â”‚
â”‚                         SET renter_verification_status = 'verified' â”‚
â”‚                              â†“                                   â”‚
â”‚    â† Returns: { success: true }                                â”‚
â”‚                                                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

ðŸ”‘ KEY POINTS:
1. Files upload IMMEDIATELY when selected (steps 2 & 5)
2. URLs stored in state (steps 3 & 6)
3. Submit sends URLs (step 9) - NO FILES
4. MySQL stores URLs in JSON columns
5. Admin fetches URLs from MySQL (step 1)
6. Admin downloads files from disk using URLs (step 2)

ðŸ’¾ STORAGE LOCATIONS:
- Files: /app/uploads/verification/{user_id}/*.pdf
- URLs: MySQL users.renter_verification_documents JSON column
- Format: { "id_proof": { "file_url": "/uploads/verification/user_123/abc.pdf" } }

=================================================================
4E. SECURE FILE SERVING (ADD TO server.py)
=================================================================

ADD THESE ROUTES TO: /app/backend/server.py
--------------------------------------------

```python
from fastapi import FastAPI, HTTPException, Depends
from fastapi.responses import FileResponse
from fastapi.staticfiles import StaticFiles
from middleware.auth_middleware import get_current_user
from models.user import User
import os

# ... (existing app initialization code) ...

# IMPORTANT: Add verification routes to server.py
from routes import verification
app.include_router(verification.router)

# =================================================================
# SECURE FILE SERVING WITH AUTHORIZATION
# =================================================================

@app.get("/uploads/verification/{user_id}/{filename}")
async def get_verification_document(
    user_id: str,
    filename: str,
    current_user: User = Depends(get_current_user)
):
    """
    Serve verification documents with authorization
    
    Security:
    - Users can only access their own documents
    - Admins can access all documents
    
    Called when admin views documents in VerificationReview.js
    """
    # Check authorization
    if current_user.user_id != user_id and not current_user.is_admin:
        raise HTTPException(
            status_code=403,
            detail="Not authorized to access this file"
        )
    
    file_path = f"/app/uploads/verification/{user_id}/{filename}"
    
    if not os.path.exists(file_path):
        raise HTTPException(
            status_code=404,
            detail="File not found"
        )
    
    return FileResponse(file_path)

@app.get("/uploads/properties/{property_id}/{filename}")
async def get_property_file(
    property_id: str,
    filename: str
):
    """
    Serve property images (public access)
    """
    file_path = f"/app/uploads/properties/{property_id}/{filename}"
    
    if not os.path.exists(file_path):
        raise HTTPException(
            status_code=404,
            detail="File not found"
        )
    
    return FileResponse(file_path)

# Mount static files for property images AFTER protected routes
# This allows public access to property images only
app.mount("/uploads/properties", StaticFiles(directory="/app/uploads/properties"), name="property-uploads")
```

=================================================================
4F. FILE STORAGE STRUCTURE ON LOCALHOST
=================================================================

When backend runs on localhost, create this directory structure:

```
/app/uploads/
â”œâ”€â”€ verification/           # PROTECTED - Only owner + admin
â”‚   â”œâ”€â”€ user_001/
â”‚   â”‚   â”œâ”€â”€ abc12345_1234567890.pdf  (Aadhaar card)
â”‚   â”‚   â””â”€â”€ def67890_1234567899.pdf  (Salary slip)
â”‚   â”œâ”€â”€ user_002/
â”‚   â”‚   â”œâ”€â”€ xyz45678_1234567900.pdf
â”‚   â”‚   â””â”€â”€ ...
â”‚   â””â”€â”€ ...
â”‚
â”œâ”€â”€ properties/            # PUBLIC - Anyone can view
â”‚   â”œâ”€â”€ prop_001/
â”‚   â”‚   â”œâ”€â”€ img1_1234567890.jpg
â”‚   â”‚   â”œâ”€â”€ img2_1234567891.jpg
â”‚   â”‚   â””â”€â”€ video_1234567892.mp4
â”‚   â”œâ”€â”€ prop_002/
â”‚   â”‚   â””â”€â”€ ...
â”‚   â””â”€â”€ ...
â”‚
â””â”€â”€ profiles/              # PUBLIC - Profile photos
    â”œâ”€â”€ user_001_profile.jpg
    â””â”€â”€ ...
```

CREATE DIRECTORIES ON BACKEND STARTUP:

```python
# Add to server.py startup
import os

# Create upload directories
os.makedirs("/app/uploads/verification", exist_ok=True)
os.makedirs("/app/uploads/properties", exist_ok=True)
os.makedirs("/app/uploads/profiles", exist_ok=True)

# Set permissions (if needed)
os.chmod("/app/uploads", 0o755)
```

=================================================================
5. UTILITY FUNCTIONS
=================================================================

FILE: /app/backend/utils/jwt_helper.py
---------------------------------------

```python
from jose import JWTError, jwt
from datetime import datetime, timedelta
from typing import Optional, Dict
import os

SECRET_KEY = os.getenv('JWT_SECRET', 'your-secret-key-change-in-production')
ALGORITHM = os.getenv('JWT_ALGORITHM', 'HS256')
ACCESS_TOKEN_EXPIRE_HOURS = int(os.getenv('JWT_EXPIRY_HOURS', '24'))

def create_access_token(data: Dict) -> str:
    """Create JWT access token"""
    to_encode = data.copy()
    expire = datetime.utcnow() + timedelta(hours=ACCESS_TOKEN_EXPIRE_HOURS)
    to_encode.update({"exp": expire})
    
    encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)
    return encoded_jwt

def decode_access_token(token: str) -> Optional[Dict]:
    """Decode JWT access token"""
    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
        return payload
    except JWTError:
        return None
```

FILE: /app/backend/utils/password_helper.py
--------------------------------------------

```python
from passlib.context import CryptContext

pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")

def hash_password(password: str) -> str:
    """Hash password using bcrypt"""
    return pwd_context.hash(password)

def verify_password(plain_password: str, hashed_password: str) -> bool:
    """Verify password against hash"""
    return pwd_context.verify(plain_password, hashed_password)
```

FILE: /app/backend/middleware/auth_middleware.py
-------------------------------------------------

```python
from fastapi import Depends, HTTPException, status
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials
from sqlalchemy.orm import Session

from config.database import get_db
from models.user import User
from utils.jwt_helper import decode_access_token

security = HTTPBearer()

async def get_current_user(
    credentials: HTTPAuthorizationCredentials = Depends(security),
    db: Session = Depends(get_db)
) -> User:
    """Dependency to get current user from JWT token"""
    token = credentials.credentials
    
    # Decode token
    payload = decode_access_token(token)
    if not payload:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid authentication credentials"
        )
    
    user_id = payload.get('user_id')
    if not user_id:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid token payload"
        )
    
    # Get user from database
    user = db.query(User).filter(User.user_id == user_id).first()
    if not user:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="User not found"
        )
    
    if not user.is_active:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="User account is inactive"
        )
    
    return user
```

=================================================================
6. MAIN SERVER FILE
=================================================================

FILE: /app/backend/server.py
-----------------------------

```python
from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
from fastapi.staticfiles import StaticFiles
import os

from config.database import Base, engine
from routes import auth, properties, chats, payments, shortlists, verification, admin

# Create upload directories on startup
os.makedirs("/app/uploads/verification", exist_ok=True)
os.makedirs("/app/uploads/properties", exist_ok=True)
os.makedirs("/app/uploads/profiles", exist_ok=True)

# Create database tables
Base.metadata.create_all(bind=engine)

# Initialize FastAPI app
app = FastAPI(
    title="Homer API",
    description="Trust-First Hybrid Rental Marketplace API",
    version="1.0.0"
)

# CORS middleware
app.add_middleware(
    CORSMiddleware,
    allow_origins=os.getenv('CORS_ORIGINS', 'http://localhost:3000').split(','),
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Include routers
app.include_router(auth.router)
app.include_router(properties.router)
app.include_router(chats.router)
app.include_router(payments.router)
app.include_router(shortlists.router)
app.include_router(verification.router)  # VERIFICATION ROUTES - CRITICAL
app.include_router(admin.router)  # Admin routes

# Health check
@app.get("/")
async def root():
    return {"message": "Homer API is running", "status": "healthy"}

@app.get("/api/health")
async def health_check():
    return {"status": "ok"}

# Run with: uvicorn server:app --host 0.0.0.0 --port 8001 --reload
```

=================================================================
6.8 ADMIN MANAGEMENT APIS
=================================================================

FILE: /app/backend/routes/admin.py
------------------------------------

```python
from fastapi import APIRouter, Depends, HTTPException, status, Request
from sqlalchemy.orm import Session
from typing import List, Optional
from datetime import datetime
import uuid

from database import get_db
from models import User, Property, Transaction, AdminAuditLog
from auth import get_current_user, require_admin
from schemas import AdminStatsResponse, UserAdminUpdate, PropertyAdminUpdate

router = APIRouter(prefix="/api/admin", tags=["admin"])

# =================================================================
# ADMIN AUTHENTICATION & AUTHORIZATION
# =================================================================

# Middleware to check admin access
def require_admin(current_user: User = Depends(get_current_user)):
    if not current_user.is_admin:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Admin access required"
        )
    return current_user

# Log admin action
async def log_admin_action(
    db: Session,
    admin_id: str,
    action_type: str,
    entity_type: str,
    entity_id: str,
    action_details: dict,
    old_value: dict = None,
    new_value: dict = None,
    request: Request = None
):
    log = AdminAuditLog(
        log_id=str(uuid.uuid4()),
        admin_id=admin_id,
        action_type=action_type,
        entity_type=entity_type,
        entity_id=entity_id,
        action_details=action_details,
        old_value=old_value,
        new_value=new_value,
        ip_address=request.client.host if request else None,
        user_agent=request.headers.get("user-agent") if request else None,
        status="success"
    )
    db.add(log)
    db.commit()

# =================================================================
# DASHBOARD & STATISTICS
# =================================================================

@router.get("/stats")
async def get_admin_stats(
    current_user: User = Depends(require_admin),
    db: Session = Depends(get_db)
):
    """Get system statistics for admin dashboard"""
    
    total_users = db.query(User).count()
    total_renters = db.query(User).filter(User.user_type.in_(['renter', 'both'])).count()
    total_owners = db.query(User).filter(User.user_type.in_(['owner', 'both'])).count()
    premium_users = db.query(User).filter(User.subscription_tier == 'premium').count()
    
    total_properties = db.query(Property).count()
    active_properties = db.query(Property).filter(Property.status == 'active').count()
    verified_properties = db.query(Property).filter(Property.is_verified == True).count()
    
    pending_renter_verifications = db.query(User).filter(
        User.renter_verification_status == 'pending'
    ).count()
    pending_owner_verifications = db.query(User).filter(
        User.owner_verification_status == 'pending'
    ).count()
    
    total_revenue = db.query(Transaction).filter(
        Transaction.payment_status == 'success'
    ).count() * 750  # Simplified calculation
    
    recent_users = db.query(User).order_by(User.created_at.desc()).limit(5).all()
    recent_properties = db.query(Property).order_by(Property.created_at.desc()).limit(5).all()
    
    return {
        "users": {
            "total": total_users,
            "renters": total_renters,
            "owners": total_owners,
            "premium": premium_users
        },
        "properties": {
            "total": total_properties,
            "active": active_properties,
            "verified": verified_properties
        },
        "verifications": {
            "pending_renters": pending_renter_verifications,
            "pending_owners": pending_owner_verifications,
            "total_pending": pending_renter_verifications + pending_owner_verifications
        },
        "revenue": {
            "total": total_revenue,
            "currency": "INR"
        },
        "recent_activity": {
            "users": [{"user_id": u.user_id, "name": u.full_name, "created_at": u.created_at} for u in recent_users],
            "properties": [{"property_id": p.property_id, "title": p.title, "created_at": p.created_at} for p in recent_properties]
        }
    }

# =================================================================
# USER MANAGEMENT
# =================================================================

@router.get("/users")
async def get_all_users(
    user_type: Optional[str] = None,
    subscription_tier: Optional[str] = None,
    verification_status: Optional[str] = None,
    page: int = 1,
    limit: int = 50,
    current_user: User = Depends(require_admin),
    db: Session = Depends(get_db)
):
    """Get all users with filters"""
    
    query = db.query(User)
    
    if user_type and user_type != 'all':
        query = query.filter(User.user_type == user_type)
    
    if subscription_tier and subscription_tier != 'all':
        query = query.filter(User.subscription_tier == subscription_tier)
    
    if verification_status:
        if verification_status == 'verified':
            query = query.filter(
                (User.is_verified_renter == True) | (User.is_verified_owner == True)
            )
        elif verification_status == 'pending':
            query = query.filter(
                (User.renter_verification_status == 'pending') | 
                (User.owner_verification_status == 'pending')
            )
    
    total = query.count()
    users = query.offset((page - 1) * limit).limit(limit).all()
    
    return {
        "users": users,
        "total_count": total,
        "page": page,
        "limit": limit,
        "has_more": (page * limit) < total
    }

@router.get("/users/{user_id}")
async def get_user_details(
    user_id: str,
    current_user: User = Depends(require_admin),
    db: Session = Depends(get_db)
):
    """Get detailed information about a specific user"""
    
    user = db.query(User).filter(User.user_id == user_id).first()
    if not user:
        raise HTTPException(status_code=404, detail="User not found")
    
    return user

@router.put("/users/{user_id}")
async def update_user(
    user_id: str,
    user_data: dict,
    request: Request,
    current_user: User = Depends(require_admin),
    db: Session = Depends(get_db)
):
    """Update user information (admin override)"""
    
    user = db.query(User).filter(User.user_id == user_id).first()
    if not user:
        raise HTTPException(status_code=404, detail="User not found")
    
    old_value = user.__dict__.copy()
    
    # Update fields
    for key, value in user_data.items():
        if hasattr(user, key) and key != 'user_id':
            setattr(user, key, value)
    
    db.commit()
    db.refresh(user)
    
    # Log action
    await log_admin_action(
        db=db,
        admin_id=current_user.user_id,
        action_type="user_update",
        entity_type="user",
        entity_id=user_id,
        action_details={"fields_updated": list(user_data.keys())},
        old_value=old_value,
        new_value=user.__dict__.copy(),
        request=request
    )
    
    return {"message": "User updated successfully", "user": user}

@router.delete("/users/{user_id}")
async def delete_user(
    user_id: str,
    request: Request,
    current_user: User = Depends(require_admin),
    db: Session = Depends(get_db)
):
    """Delete user account (admin only)"""
    
    user = db.query(User).filter(User.user_id == user_id).first()
    if not user:
        raise HTTPException(status_code=404, detail="User not found")
    
    if user.is_admin:
        raise HTTPException(status_code=403, detail="Cannot delete admin users")
    
    old_value = user.__dict__.copy()
    
    db.delete(user)
    db.commit()
    
    # Log action
    await log_admin_action(
        db=db,
        admin_id=current_user.user_id,
        action_type="user_delete",
        entity_type="user",
        entity_id=user_id,
        action_details={"user_email": old_value.get('email')},
        old_value=old_value,
        request=request
    )
    
    return {"message": "User deleted successfully"}

# =================================================================
# PROPERTY MANAGEMENT
# =================================================================

@router.get("/properties")
async def get_all_properties(
    status: Optional[str] = None,
    verification_status: Optional[str] = None,
    page: int = 1,
    limit: int = 50,
    current_user: User = Depends(require_admin),
    db: Session = Depends(get_db)
):
    """Get all properties with filters"""
    
    query = db.query(Property)
    
    if status:
        query = query.filter(Property.status == status)
    
    if verification_status == 'verified':
        query = query.filter(Property.is_verified == True)
    elif verification_status == 'unverified':
        query = query.filter(Property.is_verified == False)
    
    total = query.count()
    properties = query.offset((page - 1) * limit).limit(limit).all()
    
    return {
        "properties": properties,
        "total_count": total,
        "page": page,
        "limit": limit,
        "has_more": (page * limit) < total
    }

@router.put("/properties/{property_id}")
async def update_property(
    property_id: str,
    property_data: dict,
    request: Request,
    current_user: User = Depends(require_admin),
    db: Session = Depends(get_db)
):
    """Update property information (admin override)"""
    
    property = db.query(Property).filter(Property.property_id == property_id).first()
    if not property:
        raise HTTPException(status_code=404, detail="Property not found")
    
    old_value = property.__dict__.copy()
    
    for key, value in property_data.items():
        if hasattr(property, key) and key != 'property_id':
            setattr(property, key, value)
    
    db.commit()
    db.refresh(property)
    
    await log_admin_action(
        db=db,
        admin_id=current_user.user_id,
        action_type="property_update",
        entity_type="property",
        entity_id=property_id,
        action_details={"fields_updated": list(property_data.keys())},
        old_value=old_value,
        new_value=property.__dict__.copy(),
        request=request
    )
    
    return {"message": "Property updated successfully", "property": property}

@router.delete("/properties/{property_id}")
async def delete_property(
    property_id: str,
    request: Request,
    current_user: User = Depends(require_admin),
    db: Session = Depends(get_db)
):
    """Delete property (admin only)"""
    
    property = db.query(Property).filter(Property.property_id == property_id).first()
    if not property:
        raise HTTPException(status_code=404, detail="Property not found")
    
    old_value = property.__dict__.copy()
    
    db.delete(property)
    db.commit()
    
    await log_admin_action(
        db=db,
        admin_id=current_user.user_id,
        action_type="property_delete",
        entity_type="property",
        entity_id=property_id,
        action_details={"property_title": old_value.get('title')},
        old_value=old_value,
        request=request
    )
    
    return {"message": "Property deleted successfully"}

@router.post("/properties/{property_id}/force-verify")
async def force_verify_property(
    property_id: str,
    request: Request,
    current_user: User = Depends(require_admin),
    db: Session = Depends(get_db)
):
    """Force verify a property (admin override)"""
    
    property = db.query(Property).filter(Property.property_id == property_id).first()
    if not property:
        raise HTTPException(status_code=404, detail="Property not found")
    
    old_verified = property.is_verified
    
    property.is_verified = True
    property.verification_tier = 'verified'
    property.verification_date = datetime.utcnow()
    
    db.commit()
    db.refresh(property)
    
    await log_admin_action(
        db=db,
        admin_id=current_user.user_id,
        action_type="property_force_verify",
        entity_type="property",
        entity_id=property_id,
        action_details={"previous_status": old_verified, "new_status": True},
        request=request
    )
    
    return {"message": "Property force verified", "property": property}

# =================================================================
# VERIFICATION MANAGEMENT
# =================================================================

@router.get("/verifications/pending")
async def get_pending_verifications(
    current_user: User = Depends(require_admin),
    db: Session = Depends(get_db)
):
    """Get all pending verifications"""
    
    pending_renters = db.query(User).filter(
        User.renter_verification_status == 'pending'
    ).all()
    
    pending_owners = db.query(User).filter(
        User.owner_verification_status == 'pending'
    ).all()
    
    pending_properties = db.query(Property).filter(
        Property.is_verified == False,
        Property.verification_tier == 'pending'
    ).all()
    
    return {
        "pending_renter_verifications": pending_renters,
        "pending_owner_verifications": pending_owners,
        "pending_property_verifications": pending_properties
    }

@router.post("/verifications/approve")
async def approve_verification(
    verification_type: str,
    entity_id: str,
    request: Request,
    current_user: User = Depends(require_admin),
    db: Session = Depends(get_db)
):
    """Approve a verification request"""
    
    if verification_type == 'renter':
        user = db.query(User).filter(User.user_id == entity_id).first()
        if not user:
            raise HTTPException(status_code=404, detail="User not found")
        
        user.renter_verification_status = 'verified'
        user.is_verified_renter = True
        
    elif verification_type == 'owner':
        user = db.query(User).filter(User.user_id == entity_id).first()
        if not user:
            raise HTTPException(status_code=404, detail="User not found")
        
        user.owner_verification_status = 'verified'
        user.is_verified_owner = True
        
    elif verification_type == 'property':
        property = db.query(Property).filter(Property.property_id == entity_id).first()
        if not property:
            raise HTTPException(status_code=404, detail="Property not found")
        
        property.is_verified = True
        property.verification_tier = 'verified'
        property.verification_date = datetime.utcnow()
    
    db.commit()
    
    await log_admin_action(
        db=db,
        admin_id=current_user.user_id,
        action_type="verification_approve",
        entity_type=verification_type,
        entity_id=entity_id,
        action_details={"verification_type": verification_type},
        request=request
    )
    
    return {"message": "Verification approved successfully"}

@router.post("/verifications/reject")
async def reject_verification(
    verification_type: str,
    entity_id: str,
    reason: str,
    request: Request,
    current_user: User = Depends(require_admin),
    db: Session = Depends(get_db)
):
    """Reject a verification request"""
    
    if verification_type == 'renter':
        user = db.query(User).filter(User.user_id == entity_id).first()
        if not user:
            raise HTTPException(status_code=404, detail="User not found")
        user.renter_verification_status = 'rejected'
        
    elif verification_type == 'owner':
        user = db.query(User).filter(User.user_id == entity_id).first()
        if not user:
            raise HTTPException(status_code=404, detail="User not found")
        user.owner_verification_status = 'rejected'
    
    db.commit()
    
    await log_admin_action(
        db=db,
        admin_id=current_user.user_id,
        action_type="verification_reject",
        entity_type=verification_type,
        entity_id=entity_id,
        action_details={"verification_type": verification_type, "reason": reason},
        request=request
    )
    
    return {"message": "Verification rejected", "reason": reason}

# =================================================================
# TRANSACTION MANAGEMENT
# =================================================================

@router.get("/transactions")
async def get_all_transactions(
    transaction_type: Optional[str] = None,
    payment_status: Optional[str] = None,
    page: int = 1,
    limit: int = 50,
    current_user: User = Depends(require_admin),
    db: Session = Depends(get_db)
):
    """Get all transactions with filters"""
    
    query = db.query(Transaction)
    
    if transaction_type:
        query = query.filter(Transaction.transaction_type == transaction_type)
    
    if payment_status:
        query = query.filter(Transaction.payment_status == payment_status)
    
    total = query.count()
    transactions = query.offset((page - 1) * limit).limit(limit).all()
    
    return {
        "transactions": transactions,
        "total_count": total,
        "page": page,
        "limit": limit
    }

@router.post("/transactions/{transaction_id}/refund")
async def refund_transaction(
    transaction_id: str,
    request: Request,
    current_user: User = Depends(require_admin),
    db: Session = Depends(get_db)
):
    """Issue a refund for a transaction"""
    
    transaction = db.query(Transaction).filter(
        Transaction.transaction_id == transaction_id
    ).first()
    
    if not transaction:
        raise HTTPException(status_code=404, detail="Transaction not found")
    
    if transaction.payment_status != 'success':
        raise HTTPException(status_code=400, detail="Can only refund successful transactions")
    
    old_status = transaction.payment_status
    transaction.payment_status = 'refunded'
    transaction.refunded_at = datetime.utcnow()
    
    db.commit()
    
    await log_admin_action(
        db=db,
        admin_id=current_user.user_id,
        action_type="transaction_refund",
        entity_type="transaction",
        entity_id=transaction_id,
        action_details={
            "amount": str(transaction.amount),
            "previous_status": old_status
        },
        request=request
    )
    
    return {"message": "Refund processed successfully", "transaction": transaction}

# =================================================================
# AUDIT LOGS
# =================================================================

@router.get("/audit-logs")
async def get_audit_logs(
    action_type: Optional[str] = None,
    entity_type: Optional[str] = None,
    page: int = 1,
    limit: int = 100,
    current_user: User = Depends(require_admin),
    db: Session = Depends(get_db)
):
    """Get admin audit logs"""
    
    query = db.query(AdminAuditLog)
    
    if action_type:
        query = query.filter(AdminAuditLog.action_type == action_type)
    
    if entity_type:
        query = query.filter(AdminAuditLog.entity_type == entity_type)
    
    total = query.count()
    logs = query.order_by(AdminAuditLog.timestamp.desc()).offset((page - 1) * limit).limit(limit).all()
    
    return {
        "logs": logs,
        "total_count": total,
        "page": page,
        "limit": limit
    }
```

MODEL UPDATE: Add AdminAuditLog to models.py
---------------------------------------------

```python
class AdminAuditLog(Base):
    __tablename__ = "admin_audit_logs"
    
    log_id = Column(String(36), primary_key=True)
    admin_id = Column(String(36), ForeignKey('users.user_id'))
    action_type = Column(String(100), nullable=False)
    entity_type = Column(String(50), nullable=False)
    entity_id = Column(String(36))
    action_details = Column(JSON)
    old_value = Column(JSON)
    new_value = Column(JSON)
    ip_address = Column(String(45))
    user_agent = Column(Text)
    timestamp = Column(DateTime, default=datetime.utcnow)
    status = Column(Enum('success', 'failed', 'partial'), default='success')
    error_message = Column(Text)
```

=================================================================
7. TESTING BACKEND
=================================================================

TEST WITH CURL:

1. Register User:
```bash
curl -X POST http://localhost:8001/api/auth/register \
  -H "Content-Type: application/json" \
  -d '{
    "email": "test@example.com",
    "phone": "+919876543210",
    "password": "password123",
    "user_type": "renter",
    "full_name": "Test User"
  }'
```

2. Login:
```bash
curl -X POST http://localhost:8001/api/auth/login \
  -H "Content-Type: application/json" \
  -d '{
    "email": "test@example.com",
    "password": "password123"
  }'
```

3. Get Properties (with token):
```bash
curl -X GET http://localhost:8001/api/properties/search \
  -H "Authorization: Bearer YOUR_TOKEN_HERE"
```

=================================================================
8. INTEGRATION WITH FRONTEND
=================================================================

Frontend must:
1. Set REACT_APP_USE_MOCK_DATA=false in .env
2. Ensure REACT_APP_BACKEND_URL=http://localhost:8001/api
3. All API calls will now go to real backend

Backend must:
1. Ensure DATABASE_URL points to MySQL/MariaDB
2. Run: uvicorn server:app --host 0.0.0.0 --port 8001
3. All endpoints must return exact response format frontend expects

=================================================================
9. DEPLOYMENT CHECKLIST
=================================================================

Before deployment:
â–¡ Update SECRET_KEY and JWT_SECRET
â–¡ Update DATABASE_URL with production MySQL credentials
â–¡ Configure CORS_ORIGINS for production domain
â–¡ Add real Razorpay keys if needed
â–¡ Set DEBUG=false
â–¡ Test all endpoints
â–¡ Run database migrations
â–¡ Set up SSL/HTTPS

=================================================================
END OF BACKEND WORKFLOW
=================================================================

This backend is designed to integrate seamlessly with frontend
defined in frontend_workflow.txt. All API contracts match exactly.
```
