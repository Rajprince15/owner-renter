=================================================================
HOMER - TRUST-FIRST HYBRID RENTAL MARKETPLACE
COMPLETE FRONTEND + BACKEND WORKFLOW DOCUMENT
=================================================================

â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                    ðŸ”  IMPORTANT NOTE  ðŸ”                     â•‘
â•‘                                                               â•‘
â•‘  DATABASE STRATEGY: MySQL (Production) / MariaDB (Dev)       â•‘
â•‘  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€   â•‘
â•‘  â€¢ USER (You): Will use MySQL with YOUR secure credentials  â•‘
â•‘  â€¢ LLM (AI): Will use MariaDB locally (can't access your    â•‘
â•‘    real MySQL password for security)                         â•‘
â•‘  â€¢ COMPATIBILITY: 100% - MariaDB is MySQL-compatible         â•‘
â•‘  â€¢ DEPLOYMENT: Just update .env with YOUR MySQL credentials â•‘
â•‘                No code changes needed!                       â•‘
â•‘                                                               â•‘
â•‘  See "DATABASE STRATEGY" section below for full details.    â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

TABLE OF CONTENTS:
1. Tech Stack Overview
2. Database Schema Design
3. Backend API Endpoints
4. Frontend Page Structure
5. User Flows & Workflows
6. UI/UX Design Guidelines
7. Advanced Features Implementation
8. Security & Privacy Considerations
9. Payment Integration
10. Development Phases

=================================================================
1. TECH STACK OVERVIEW
=================================================================

FRONTEND:
- React.js (Single Page Application)
- Tailwind CSS (Responsive, modern UI)
- React Router (Navigation)
- Axios (API calls)
- React Context/Redux (State management)
- React Hook Form (Form handling)
- MapBox/Google Maps API (Location features)
- Chart.js (Analytics dashboards)
- NOTE: Real-time chat via REST API initially (WebSocket upgrade in future phase)

BACKEND:
- FastAPI (Python)
- **DATABASE: MySQL (Production) / MariaDB (Development)**
  * **PRODUCTION (USER):** MySQL database with your secure credentials
  * **DEVELOPMENT (LLM):** MariaDB (100% MySQL-compatible, local setup)
  * **REASON:** Keep your real MySQL password private and secure
  * **COMPATIBILITY:** MariaDB is a drop-in replacement - identical SQL syntax
  * **SWITCHING:** Simply update DATABASE_URL in .env when deploying to production
- JWT (Authentication)
- AWS S3/Cloudinary (Document & image storage)
- Razorpay Payment Gateway (India-focused)
- Email Service (SendGrid/SMTP)
- SMS Service (Twilio/AWS SNS) - Optional
- Emergent LLM Integration (for AI-powered natural language search)

=================================================================
âš ï¸  CRITICAL DATABASE STRATEGY - READ CAREFULLY âš ï¸
=================================================================
**WHY TWO DATABASES?**
You want to use MySQL in production but cannot share your real MySQL password
with the LLM for security reasons. Solution: LLM uses MariaDB locally.

**DEVELOPMENT ENVIRONMENT (LLM WILL USE THIS):**
- Database: MariaDB (MySQL-compatible fork)
- Connection: mysql://root@localhost:3306/homer_db (no password needed)
- Setup: Local MariaDB installation
- Access: LLM can freely develop using this
- Security: Your production credentials remain private

**PRODUCTION ENVIRONMENT (YOU WILL USE THIS):**
- Database: MySQL (your actual database)
- Connection: mysql://username:your_password@your_host:3306/homer_db
- Setup: Your existing MySQL server
- Access: Only you have the credentials
- Security: Password never shared with LLM

**100% COMPATIBILITY GUARANTEE:**
- MariaDB is a drop-in replacement for MySQL
- Same SQL syntax, same data types
- All queries work on both without any changes
- Schema is identical between both systems

**HOW TO SWITCH FROM DEV TO PRODUCTION:**
1. LLM develops entire application using local MariaDB
2. When ready to deploy, YOU update .env file:
   Change: DATABASE_URL=mysql://root@localhost:3306/homer_db
   To: DATABASE_URL=mysql://your_user:your_password@your_host:3306/homer_db
3. Run the same schema creation scripts on your MySQL
4. Application works identically - zero code changes needed!

**SECURITY BENEFITS:**
âœ“ Your production MySQL password stays completely private
âœ“ LLM never needs or sees your real credentials
âœ“ Development and production environments isolated
âœ“ No risk of accidental credential exposure

THIRD-PARTY INTEGRATIONS (MOCK-FIRST APPROACH):
- Google Places API (Location autocomplete) - Mock with predefined cities
- AQI Data API (Air quality) - Mock with random realistic values
- Walkability Score API - Mock with calculated scores
- Noise pollution estimation - Mock based on location type
- Razorpay Payment Gateway - Mock payment flow initially
- Emergent LLM Key - For natural language search processing
- Document verification services (manual review initially)

=================================================================
1.1 ENVIRONMENT CONFIGURATION STRATEGY
=================================================================

CRITICAL DESIGN PRINCIPLE: MOCK-FIRST, PRODUCTION-READY

All external integrations MUST be designed with a "switchable" architecture:
- By default, use MOCK data and MOCK implementations
- When API keys are added to .env file, automatically switch to REAL APIs
- NO code changes required to switch between mock and production

ENVIRONMENT VARIABLES (.env file structure):

# === APPLICATION CONFIG ===
APP_NAME=Homer
APP_ENV=development  # development | production
DEBUG=true
SECRET_KEY=your-secret-key-here

# === DATABASE CONFIG ===
# âš ï¸ IMPORTANT: Read database strategy in Tech Stack section above
# 
# DEVELOPMENT (LLM USES THIS - MariaDB):
DATABASE_URL=mysql://root@localhost:3306/homer_db  # Local MariaDB, no password
# 
# PRODUCTION (YOU WILL USE THIS - MySQL):
# DATABASE_URL=mysql://your_username:your_password@your_mysql_host:3306/homer_db
# 
# TO DEPLOY TO PRODUCTION:
# 1. Comment out the MariaDB line above
# 2. Uncomment and update the MySQL line with YOUR credentials
# 3. LLM never sees your production password - it stays secure with you
# 4. No code changes needed - 100% compatible!

# === JWT CONFIG ===
JWT_SECRET=your-jwt-secret-here
JWT_ALGORITHM=HS256
JWT_EXPIRY_HOURS=24

# === PAYMENT GATEWAY (RAZORPAY) ===
# Leave empty for MOCK payment flow
RAZORPAY_KEY_ID=
RAZORPAY_KEY_SECRET=
RAZORPAY_WEBHOOK_SECRET=
# When empty, system uses mock payment that always succeeds

# === LIFESTYLE DATA APIs ===
# Leave empty for MOCK data generation
AQI_API_KEY=
AQI_API_URL=
WALKABILITY_API_KEY=
# When empty, system generates realistic mock values

# === LOCATION SERVICES ===
# Leave empty for predefined city/locality data
GOOGLE_MAPS_API_KEY=
GOOGLE_PLACES_API_KEY=
# When empty, uses hardcoded Indian cities and localities

# === FILE STORAGE ===
# Leave empty for local file storage
AWS_ACCESS_KEY_ID=
AWS_SECRET_ACCESS_KEY=
AWS_S3_BUCKET_NAME=
CLOUDINARY_CLOUD_NAME=
CLOUDINARY_API_KEY=
CLOUDINARY_API_SECRET=
# When empty, stores files in /uploads directory

# === EMAIL SERVICE ===
# Leave empty to skip email sending (logs only)
SENDGRID_API_KEY=
SMTP_HOST=
SMTP_PORT=
SMTP_USERNAME=
SMTP_PASSWORD=
EMAIL_FROM=noreply@homer.com
# When empty, logs email content to console

# === LLM INTEGRATION (EMERGENT) ===
EMERGENT_LLM_KEY=your-emergent-llm-key
# Used for natural language search processing
# Supports OpenAI, Anthropic, Google models

# === FRONTEND CONFIG ===
REACT_APP_BACKEND_URL=http://localhost:8001/api
REACT_APP_GOOGLE_MAPS_KEY=
# When empty, uses static map images

MOCK DATA IMPLEMENTATION STRATEGY:

1. PAYMENT MOCK (Razorpay):
   - If RAZORPAY_KEY_ID is empty â†’ Use mock payment
   - Mock flow: Show payment form â†’ Always return success after 2 seconds
   - Generate mock transaction_id
   - Store in transactions collection as normal
   - UI shows "TEST MODE" banner

2. LIFESTYLE DATA MOCK:
   - If AQI_API_KEY is empty â†’ Generate mock data
   - Mock logic:
     * AQI: Random between 30-150 (weighted toward 50-80)
     * Walkability: Calculate based on area type (80-90 for city center, 40-60 for suburbs)
     * Noise: Calculate based on road proximity (50-70 dB)
   - Cache mock data per location for consistency

3. LOCATION AUTOCOMPLETE MOCK:
   - If GOOGLE_PLACES_API_KEY is empty â†’ Use predefined data
   - Hardcode top 50 Indian cities
   - Hardcode popular localities per city
   - Simple string matching for autocomplete

4. FILE STORAGE MOCK:
   - If AWS/Cloudinary keys empty â†’ Use local storage
   - Create /uploads folder structure
   - Store files with unique UUIDs
   - Serve via FastAPI static files

5. EMAIL MOCK:
   - If SENDGRID_API_KEY empty â†’ Console logging
   - Log email subject, recipient, and body to console
   - Return success immediately

6. LLM INTEGRATION (REAL - Emergent LLM Key):
   - Use Emergent LLM key for natural language processing
   - Extract intent from natural language search queries
   - Example: "quiet 2bhk near park" â†’ {max_noise: 60, bhk: "2BHK", near_parks: true}
   - Fallback to keyword matching if LLM fails

SWITCHING TO PRODUCTION:
- Step 1: Obtain API keys from respective services
- Step 2: Add keys to .env file
- Step 3: **UPDATE DATABASE_URL with YOUR MySQL credentials**
- Step 4: Restart backend server
- Step 5: System automatically uses real APIs and YOUR MySQL database
- Step 6: Remove "TEST MODE" banners from UI

DATABASE MIGRATION FROM DEVELOPMENT TO PRODUCTION:
- Development uses: MariaDB (mysql://root@localhost:3306/homer_db)
- Production uses: MySQL (mysql://your_user:your_pass@your_host:3306/homer_db)
- Steps to migrate:
  1. Export schema from MariaDB (LLM will create this during development)
  2. Import same schema to YOUR MySQL database
  3. Update DATABASE_URL in backend/.env with YOUR MySQL credentials
  4. Restart backend
  5. Application works identically - zero code changes!
- All SQL queries are 100% compatible between MariaDB and MySQL

=================================================================
2. DATABASE SCHEMA DESIGN (MySQL/MariaDB Tables)
=================================================================

â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘  âš ï¸  CRITICAL: DATABASE IMPLEMENTATION STRATEGY  âš ï¸           â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

**FOR THE LLM (DEVELOPMENT ENVIRONMENT):**
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Database: MariaDB (MySQL-compatible)                        â”‚
â”‚ Connection: mysql://root@localhost:3306/homer_db           â”‚
â”‚ Password: NONE (local development only)                     â”‚
â”‚ Purpose: LLM will implement entire app using this          â”‚
â”‚ Installation: Will be available in container/local env     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

**FOR THE USER (PRODUCTION ENVIRONMENT):**
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Database: MySQL (user's production database)                â”‚
â”‚ Connection: mysql://[YOUR_USER]:[YOUR_PASS]@[HOST]/homer_dbâ”‚
â”‚ Password: YOUR PRIVATE CREDENTIALS (never shared with LLM) â”‚
â”‚ Purpose: Your actual production database                    â”‚
â”‚ Deployment: You update .env with YOUR credentials later    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

**COMPATIBILITY GUARANTEE:**
âœ“ MariaDB is 100% MySQL-compatible (same SQL, same datatypes)
âœ“ Every query works identically on both systems
âœ“ Schema below works on BOTH MariaDB and MySQL without changes
âœ“ Zero code modifications needed when switching
âœ“ LLM develops on MariaDB â†’ You deploy to MySQL seamlessly

**SECURITY APPROACH:**
âœ“ Your production MySQL password NEVER exposed to LLM
âœ“ Development uses local MariaDB with no password
âœ“ Production credentials stay securely with you
âœ“ Switch databases by updating ONE line in .env file

**DEPLOYMENT STEPS:**
1. LLM completes entire development using MariaDB locally
2. All tables, schemas, queries tested on MariaDB
3. When ready to deploy, YOU update .env:
   DATABASE_URL=mysql://your_user:your_pass@your_host:3306/homer_db
4. Run same schema creation scripts on YOUR MySQL
5. Application works identically - ZERO code changes!

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

The following schema design works on BOTH MariaDB (development) and MySQL (production).
All SQL commands below are 100% compatible with both systems.

SCHEMA DESIGN:
--------------
The following schema uses relational database design principles.
JSON columns are used where appropriate for flexibility (MySQL 5.7+ / MariaDB 10.2+ support JSON).

TABLE: users
CREATE TABLE users (
  user_id VARCHAR(36) PRIMARY KEY,
  email VARCHAR(255) UNIQUE NOT NULL,
  phone VARCHAR(20) UNIQUE NOT NULL,
  password_hash VARCHAR(255) NOT NULL,
  user_type ENUM('renter', 'owner', 'both') NOT NULL,
  full_name VARCHAR(255),
  profile_photo_url TEXT,
  date_of_birth DATE,
  gender VARCHAR(20),
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  last_login TIMESTAMP NULL,
  is_active BOOLEAN DEFAULT TRUE,
  
  -- Renter profile fields
  subscription_tier ENUM('free', 'premium') DEFAULT 'free',
  subscription_start TIMESTAMP NULL,
  subscription_end TIMESTAMP NULL,
  is_verified_renter BOOLEAN DEFAULT FALSE,
  renter_verification_status ENUM('none', 'pending', 'verified', 'rejected') DEFAULT 'none',
  renter_verification_documents JSON,  -- Store document info as JSON
  renter_preferences JSON,  -- Store preferences as JSON
  employment_info JSON,  -- Store employment info as JSON
  contacts_used INT DEFAULT 0,
  profile_visibility BOOLEAN DEFAULT TRUE,
  
  -- Owner profile fields
  is_verified_owner BOOLEAN DEFAULT FALSE,
  owner_verification_status ENUM('none', 'pending', 'verified', 'rejected') DEFAULT 'none',
  
  INDEX idx_email (email),
  INDEX idx_phone (phone),
  INDEX idx_user_type (user_type),
  INDEX idx_subscription_tier (subscription_tier)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;

-- Example JSON structure for renter_verification_documents:
/*
{
  "id_proof": {
    "type": "aadhaar",
    "document_url": "/uploads/verification/...",
    "verified": false
  },
  "income_proof": {
    "type": "salary_slip",
    "document_urls": ["/uploads/verification/..."],
    "verified": false
  }
}
*/

-- Example JSON structure for renter_preferences:
/*
{
  "budget_min": 15000,
  "budget_max": 30000,
  "bhk_type": ["2BHK", "3BHK"],
  "preferred_locations": ["Koramangala", "Indiranagar"],
  "move_in_date": "2025-02-01",
  "lifestyle_preferences": {
    "max_aqi": 60,
    "max_noise_level": 65,
    "min_walkability_score": 70,
    "near_parks": true,
    "pet_friendly": false,
    "furnished": "semi-furnished"
  }
}
*/

-- Example JSON structure for employment_info:
/*
{
  "company_name": "Tech Corp",
  "designation": "Software Engineer",
  "employment_type": "salaried",
  "annual_income": 1500000
}
*/

COLLECTION: properties
{
  property_id: UUID (primary key),
  owner_id: UUID (foreign key -> users),
  created_at: DateTime,
  updated_at: DateTime,
  status: Enum ["active", "inactive", "rented", "deleted"],
  
  // Basic Information
  title: String,
  description: String,
  property_type: String, // "apartment", "villa", "independent_house", "pg"
  bhk_type: String, // "1BHK", "2BHK", "3BHK", "4BHK+"
  
  // Location
  location: {
    address: String,
    city: String,
    state: String,
    pincode: String,
    latitude: Number,
    longitude: Number,
    locality: String,
    landmarks: [String]
  },
  
  // Pricing
  rent: Number,
  security_deposit: Number,
  maintenance_charges: Number,
  
  // Property Details
  details: {
    carpet_area: Number, // in sq ft
    total_floors: Number,
    floor_number: Number,
    furnishing: String, // "furnished", "semi-furnished", "unfurnished"
    parking: {
      car: Number,
      bike: Number
    },
    amenities: [String], // ["gym", "swimming_pool", "lift", "power_backup", "security", "park"]
    bathrooms: Number,
    balconies: Number,
    facing: String, // "north", "south", "east", "west"
    age_of_property: Number, // in years
    available_from: Date,
    preferred_tenants: [String], // ["family", "bachelor", "company"]
    pets_allowed: Boolean,
    vegetarian_only: Boolean
  },
  
  // Media
  images: [String], // URLs
  video_url: String,
  virtual_tour_url: String,
  
  // Verification
  is_verified: Boolean,
  verification_tier: Enum ["free", "verified"],
  verification_date: DateTime,
  verification_documents: {
    owner_id_proof: {
      type: String,
      document_url: String,
      verified: Boolean
    },
    ownership_proof: {
      type: String, // "electricity_bill", "property_tax", "sale_deed"
      document_url: String,
      verified: Boolean
    }
  },
  verification_fee_paid: Boolean,
  payment_id: String,
  
  // Lifestyle Data (Premium feature)
  lifestyle_data: {
    aqi_score: Number,
    noise_level: Number, // dB
    walkability_score: Number, // 0-100
    nearby_parks: [
      {
        name: String,
        distance: Number // in km
      }
    ],
    nearby_hospitals: [{name: String, distance: Number}],
    nearby_schools: [{name: String, distance: Number}],
    nearby_malls: [{name: String, distance: Number}],
    public_transport_score: Number,
    safety_score: Number,
    calculated_at: DateTime
  },
  
  // Analytics
  analytics: {
    total_views: Number,
    premium_views: Number,
    total_contacts: Number,
    shortlisted_count: Number,
    last_viewed: DateTime
  }
}

COLLECTION: chats
{
  chat_id: UUID (primary key),
  property_id: UUID (foreign key -> properties),
  renter_id: UUID (foreign key -> users),
  owner_id: UUID (foreign key -> users),
  initiated_by: String, // "renter" or "owner" (for reverse marketplace)
  created_at: DateTime,
  last_message_at: DateTime,
  status: Enum ["active", "archived", "blocked"],
  
  messages: [
    {
      message_id: UUID,
      sender_id: UUID,
      sender_type: String, // "renter" or "owner"
      message: String,
      timestamp: DateTime,
      is_read: Boolean,
      attachments: [String] // URLs
    }
  ]
}

COLLECTION: transactions
{
  transaction_id: UUID (primary key),
  user_id: UUID (foreign key -> users),
  transaction_type: Enum ["renter_subscription", "property_verification"],
  amount: Number,
  currency: String,
  payment_gateway: String,
  payment_id: String, // Gateway transaction ID
  payment_status: Enum ["pending", "success", "failed", "refunded"],
  created_at: DateTime,
  updated_at: DateTime,
  
  // Metadata
  metadata: {
    subscription_duration: Number, // days
    property_id: UUID, // if property verification
    invoice_url: String
  }
}

COLLECTION: shortlists
{
  shortlist_id: UUID (primary key),
  user_id: UUID (foreign key -> users),
  property_id: UUID (foreign key -> properties),
  created_at: DateTime,
  notes: String
}

COLLECTION: reviews (Future feature)
{
  review_id: UUID (primary key),
  property_id: UUID,
  renter_id: UUID,
  rating: Number, // 1-5
  comment: String,
  created_at: DateTime,
  is_verified_tenant: Boolean
}

COLLECTION: notifications
{
  notification_id: UUID (primary key),
  user_id: UUID (foreign key -> users),
  type: String, // "new_message", "property_view", "subscription_expiry", etc.
  title: String,
  message: String,
  is_read: Boolean,
  created_at: DateTime,
  action_url: String
}

=================================================================
3. BACKEND API ENDPOINTS (RESTful + WebSocket)
=================================================================

BASE URL: /api

--- AUTHENTICATION ENDPOINTS ---

POST   /api/auth/register
Body: {email, phone, password, user_type, full_name}
Response: {user_id, token, user_type}

POST   /api/auth/login
Body: {email/phone, password}
Response: {user_id, token, user_type, profile}

POST   /api/auth/logout
Headers: {Authorization: Bearer <token>}
Response: {message}

POST   /api/auth/forgot-password
Body: {email}
Response: {message}

POST   /api/auth/reset-password
Body: {reset_token, new_password}
Response: {message}

POST   /api/auth/verify-otp
Body: {phone/email, otp}
Response: {verified: Boolean}

--- USER PROFILE ENDPOINTS ---

GET    /api/users/profile
Headers: {Authorization: Bearer <token>}
Response: {user profile object}

PUT    /api/users/profile
Headers: {Authorization: Bearer <token>}
Body: {updated profile fields}
Response: {updated profile}

POST   /api/users/upload-document
Headers: {Authorization: Bearer <token>}
Body: FormData {document_type, file}
Response: {document_url}

PUT    /api/users/renter/preferences
Headers: {Authorization: Bearer <token>}
Body: {preferences object}
Response: {updated preferences}

GET    /api/users/renter/contacts-remaining
Headers: {Authorization: Bearer <token>}
Response: {contacts_used, contacts_limit, is_premium}

--- PROPERTY ENDPOINTS ---

POST   /api/properties/create
Headers: {Authorization: Bearer <token>}
Body: {property details}
Response: {property_id, property object}

GET    /api/properties/search
Query: {city, min_price, max_price, bhk_type, location, page, limit, sort_by}
Response: {properties: [], total_count, page, has_more}

GET    /api/properties/lifestyle-search (Premium only)
Query: {max_aqi, max_noise, min_walkability, near_parks, budget, bhk, location}
Response: {properties: [], total_count}

GET    /api/properties/:property_id
Response: {property object with all details}

PUT    /api/properties/:property_id
Headers: {Authorization: Bearer <token>}
Body: {updated fields}
Response: {updated property}

DELETE /api/properties/:property_id
Headers: {Authorization: Bearer <token>}
Response: {message}

POST   /api/properties/:property_id/upload-images
Headers: {Authorization: Bearer <token>}
Body: FormData {images[]}
Response: {image_urls: []}

GET    /api/properties/:property_id/analytics
Headers: {Authorization: Bearer <token>}
Response: {analytics object}

POST   /api/properties/:property_id/verify
Headers: {Authorization: Bearer <token>}
Body: {verification_documents}
Response: {verification_status, payment_required}

--- REVERSE MARKETPLACE ENDPOINTS ---

GET    /api/reverse-marketplace/renters (Verified owners only)
Headers: {Authorization: Bearer <token>}
Query: {budget_min, budget_max, location, employment_type, page, limit}
Response: {renters: [anonymous profiles], total_count}

POST   /api/reverse-marketplace/contact-renter
Headers: {Authorization: Bearer <token>}
Body: {renter_id, message}
Response: {chat_id}

--- CHAT ENDPOINTS ---

GET    /api/chats
Headers: {Authorization: Bearer <token>}
Response: {chats: []}

GET    /api/chats/:chat_id
Headers: {Authorization: Bearer <token>}
Response: {chat object with messages}

POST   /api/chats/initiate
Headers: {Authorization: Bearer <token>}
Body: {property_id, initial_message}
Response: {chat_id}

POST   /api/chats/:chat_id/messages
Headers: {Authorization: Bearer <token>}
Body: {message, attachments}
Response: {message_id}

PUT    /api/chats/:chat_id/mark-read
Headers: {Authorization: Bearer <token>}
Response: {message}

WebSocket: /ws/chat/:chat_id
For real-time messaging

--- SHORTLIST ENDPOINTS ---

POST   /api/shortlists/add
Headers: {Authorization: Bearer <token>}
Body: {property_id, notes}
Response: {shortlist_id}

GET    /api/shortlists
Headers: {Authorization: Bearer <token>}
Response: {shortlisted_properties: []}

DELETE /api/shortlists/:shortlist_id
Headers: {Authorization: Bearer <token>}
Response: {message}

--- PAYMENT ENDPOINTS ---

POST   /api/payments/create-order
Headers: {Authorization: Bearer <token>}
Body: {type: "subscription" | "verification", metadata}
Response: {order_id, amount, payment_gateway_data}

POST   /api/payments/verify
Headers: {Authorization: Bearer <token>}
Body: {payment_id, order_id, signature}
Response: {success: Boolean, transaction_id}

GET    /api/payments/history
Headers: {Authorization: Bearer <token>}
Response: {transactions: []}

--- ADMIN ENDPOINTS (Future) ---

GET    /api/admin/verifications/pending
POST   /api/admin/verifications/:id/approve
POST   /api/admin/verifications/:id/reject

--- UTILITY ENDPOINTS ---

GET    /api/locations/autocomplete
Query: {query}
Response: {suggestions: []}

GET    /api/lifestyle-data/calculate
Query: {latitude, longitude}
Response: {aqi, noise_level, walkability_score, nearby_amenities}

GET    /api/notifications
Headers: {Authorization: Bearer <token>}
Response: {notifications: []}

PUT    /api/notifications/:id/read
Headers: {Authorization: Bearer <token>}
Response: {message}

=================================================================
4. FRONTEND PAGE STRUCTURE & ROUTING
=================================================================

PUBLIC PAGES (No authentication required):
------------------------------------------

1. / (Landing Page)
   - Hero section with value proposition
   - Feature highlights for renters and owners
   - Trust indicators (verification badges, user testimonials)
   - CTA buttons: "Find a Home" and "List Property"
   - How it works sections
   - Pricing comparison: Free vs Premium
   - Footer with links

2. /search
   - Property search interface
   - Filters sidebar (basic for free, advanced for premium)
   - Property cards grid
   - Map view toggle
   - Sort options
   - Pagination
   - Upsell banner for free users

3. /property/:id
   - Full property details
   - Image gallery with lightbox
   - Location map
   - Amenities list
   - Lifestyle data (if verified property)
   - Owner info (masked until contact)
   - "Contact Owner" button (triggers auth/subscription check)
   - Similar properties section

4. /login
   - Email/Phone login form
   - OTP verification option
   - Social login (Google, Facebook)
   - Link to signup

5. /signup
   - Registration form
   - User type selection (Renter/Owner/Both)
   - Email/Phone verification
   - Link to login

6. /about
   - Company mission
   - How verification works
   - Trust & safety information

7. /pricing
   - Side-by-side comparison
   - Renter tiers (Free vs Premium)
   - Owner tiers (Free vs Verified)
   - Feature matrix
   - FAQ section

PROTECTED PAGES (Authentication required):
-------------------------------------------

COMMON:

8. /dashboard
   - Role-based dashboard (renter/owner)
   - Quick stats
   - Recent activity
   - Notifications bell

RENTER PAGES:

9. /dashboard/renter
   - Search suggestions based on preferences
   - Recently viewed properties
   - Shortlisted properties
   - Chat overview
   - Subscription status
   - Contacts remaining (if free tier)

10. /renter/profile
    - Personal information
    - Preferences form
    - Employment details
    - Document upload for verification
    - Subscription management
    - Privacy settings (reverse marketplace visibility)

11. /renter/subscription
    - Current plan details
    - Upgrade to premium CTA
    - Feature comparison
    - Payment form

12. /renter/shortlists
    - Grid of shortlisted properties
    - Notes for each
    - Quick actions (contact, remove, compare)

13. /renter/chats
    - List of all conversations
    - Real-time chat interface
    - Property details sidebar
    - Attachment support

OWNER PAGES:

14. /dashboard/owner
    - Properties overview
    - Performance analytics
    - Recent inquiries
    - Verification status
    - Revenue/subscription info

15. /owner/properties
    - List of all properties
    - Add new property button
    - Edit/Delete actions
    - Status indicators (verified/unverified)
    - Analytics preview

16. /owner/property/add
    - Multi-step form
    - Property details
    - Location picker
    - Image upload (drag & drop)
    - Amenities checklist
    - Preview before submit

17. /owner/property/:id/edit
    - Same as add but pre-filled
    - Can't edit if rented

18. /owner/property/:id/analytics
    - Views graph (time-based)
    - Contact requests
    - Shortlist count
    - Comparison with similar properties
    - Performance tips

19. /owner/verification
    - Document upload form
    - Verification status tracker
    - Payment for verification
    - Benefits explainer

20. /owner/reverse-marketplace
    - Browse verified renters
    - Filter by budget, location, income
    - Anonymous renter profiles
    - "Contact Renter" button
    - Requires verified owner status

21. /owner/chats
    - Same as renter chats
    - Organized by property

SHARED:

22. /profile/settings
    - Account settings
    - Change password
    - Notification preferences
    - Delete account

23. /payment/success
    - Success message
    - Invoice download
    - Next steps

24. /payment/failure
    - Error message
    - Retry option
    - Support contact

25. /notifications
    - All notifications list
    - Filterable by type
    - Mark as read

26. /help
    - FAQ
    - Contact support form
    - Live chat (if available)

=================================================================
5. DETAILED USER FLOWS & WORKFLOWS
=================================================================

FLOW 1: FREE RENTER BROWSING & UPGRADE
---------------------------------------
1. User lands on homepage
2. Clicks "Find a Home"
3. Redirected to /search
4. Can browse all properties with basic filters
5. Clicks on a property -> /property/:id
6. Sees full details but "Contact Owner" requires login
7. Clicks "Contact Owner" -> Redirected to /login or /signup
8. After login, contact limit check:
   - If contacts < 5: Creates chat, contacts_used++
   - If contacts >= 5: Modal pops up:
     "You've reached your contact limit. Upgrade to Premium for unlimited contacts, verification badge, and advanced search"
     CTA: "Upgrade Now" -> /renter/subscription
9. Completes payment
10. Status upgraded to Premium
11. Can now contact unlimited owners + gets verification option + lifestyle search

FLOW 2: PREMIUM RENTER VERIFICATION & REVERSE MARKETPLACE
----------------------------------------------------------
1. Premium renter logs in
2. Goes to /renter/profile
3. Sees "Get Verified" section
4. Uploads:
   - ID proof (Aadhaar/PAN)
   - Income proof (salary slips/bank statements)
5. Fills employment details
6. Submits for verification
7. Admin reviews (manual process)
8. Once verified:
   - Gets "Verified Renter" badge
   - Profile becomes visible in reverse marketplace (if opted in)
9. Verified owners can now browse and contact them

FLOW 3: FREE OWNER LISTING & VERIFICATION UPSELL
-------------------------------------------------
1. Owner logs in
2. Goes to /owner/property/add
3. Fills multi-step form:
   - Basic info (title, type, BHK)
   - Location (autocomplete + map picker)
   - Details (rent, deposit, amenities)
   - Images upload
   - Preview & submit
4. Property listed as "Unverified"
5. Property shows in search but:
   - At bottom of results
   - With "Not Verified" warning
   - No lifestyle data calculated
6. Owner sees dashboard analytics:
   "Your unverified listing is getting 90% fewer views. Get verified to rank higher and attract premium renters."
7. Clicks "Get Verified" -> /owner/verification
8. Uploads:
   - ID proof
   - Ownership proof (electricity bill/property tax)
9. Completes payment (â‚¹2,000)
10. Admin reviews
11. Once verified:
    - "Verified Property" badge
    - Top ranking in search
    - Lifestyle data calculated and shown
    - Access to reverse marketplace

FLOW 4: VERIFIED OWNER BROWSING REVERSE MARKETPLACE
----------------------------------------------------
1. Verified owner logs in
2. Goes to /owner/reverse-marketplace
3. Sees list of verified premium renters (anonymous):
   "Renter #1024
   - IT Professional at verified MNC
   - Income: >15 LPA
   - Looking for: 2BHK in Koramangala
   - Budget: â‚¹25,000-30,000
   - Move-in: Dec 1
   - Preferences: Low AQI, quiet area, pet-friendly"
4. Applies filters (budget, location, move-in date)
5. Finds matching renter
6. Clicks "Contact Renter"
7. Writes initial message
8. Chat created (owner initiates)
9. Renter receives notification
10. Both can continue conversation

FLOW 5: LIFESTYLE SEARCH (PREMIUM FEATURE)
-------------------------------------------
1. Premium renter goes to /search
2. Sees "Advanced Lifestyle Search" tab
3. Can filter by:
   - Max AQI level (e.g., <50)
   - Max noise level (e.g., <60 dB)
   - Min walkability score (e.g., >70)
   - Near parks (toggle)
   - Pet-friendly (toggle)
   - Natural language search: "Quiet 2BHK near park in low-pollution area"
4. Results show only verified properties with lifestyle data
5. Each property card shows lifestyle scores
6. Click property to see full lifestyle report

FLOW 6: CHAT & PROPERTY INQUIRY
--------------------------------
1. Renter clicks "Contact Owner" on property
2. Chat initiated (/api/chats/initiate)
3. Redirected to /renter/chats/:chat_id
4. Real-time messaging interface
5. Can send text + attachments
6. Owner receives notification
7. Owner replies from /owner/chats
8. Both can continue until deal is closed
9. Can mark chat as archived

FLOW 7: PAYMENT FLOW (SUBSCRIPTION/VERIFICATION)
-------------------------------------------------
1. User clicks "Upgrade to Premium" or "Get Verified"
2. Redirected to payment page
3. Sees pricing, features, invoice preview
4. Clicks "Pay Now"
5. Backend creates order (/api/payments/create-order)
6. Razorpay/Stripe checkout modal opens
7. User completes payment
8. Payment verified (/api/payments/verify)
9. Subscription/verification status updated in DB
10. Redirected to /payment/success
11. Receives email confirmation
12. Features unlocked immediately

=================================================================
6. UI/UX DESIGN GUIDELINES & EFFECTS
=================================================================

DESIGN PHILOSOPHY:
- Clean, modern, trustworthy aesthetic
- Emphasize trust signals (badges, verification checks)
- Use white space generously
- Professional color scheme (avoid loud colors)
- Mobile-first responsive design

COLOR PALETTE:
Primary: #2563EB (Trust blue)
Secondary: #10B981 (Success green for verified)
Accent: #F59E0B (Call-to-action orange)
Neutral: #1F2937 (Dark text)
Background: #F9FAFB (Light gray)
Error: #EF4444 (Red)
Warning: #FCD34D (Yellow for unverified)

TYPOGRAPHY:
Headings: Inter or Poppins (Bold)
Body: Inter or System fonts
Code/Numbers: Mono

KEY UI COMPONENTS & EFFECTS:
-----------------------------

1. PROPERTY CARDS:
   - Shadow on hover with smooth transition
   - Verified badge (green checkmark) top-right
   - Image carousel with dots
   - Lifestyle scores as small badges (AQI, Walkability)
   - Hover: Scale up 1.02x, shadow increases
   - Quick actions overlay on hover (Shortlist, Compare, Share)

2. TRUST BADGES:
   - Verified Property: Green badge with checkmark
   - Premium Renter: Blue badge with star
   - Unverified: Yellow warning badge
   - Animate on page load (fade in + slight scale)

3. SEARCH FILTERS:
   - Collapsible filter sidebar
   - Chips for selected filters
   - Clear all button
   - Range sliders for price/date
   - Map view toggle with slide transition

4. HERO SECTION (LANDING PAGE):
   - Animated gradient background
   - Floating property cards animation
   - Search bar with autocomplete
   - Dual CTA buttons (Renter vs Owner)
   - Trust signals: "1000+ Verified Properties" with counter animation

5. UPSELL MODALS:
   - Blur background (backdrop)
   - Feature comparison table
   - Clear value proposition
   - Social proof (testimonials)
   - Exit intent detection

6. CHAT INTERFACE:
   - WhatsApp-style bubbles
   - Online/offline indicators
   - Typing indicators (animated dots)
   - Message read receipts
   - Smooth scroll to bottom on new message

7. ANALYTICS DASHBOARD:
   - Animated charts (Chart.js)
   - Count-up numbers for stats
   - Comparison arrows (up/down trends)
   - Date range picker
   - Export data button

8. FORM INPUTS:
   - Floating labels
   - Real-time validation
   - Error messages with icons
   - Success checkmarks
   - Progress indicators for multi-step forms

9. LIFESTYLE DATA DISPLAY:
   - Progress bars with colors:
     * AQI: Green (<50), Yellow (50-100), Red (>100)
     * Noise: Green (<50dB), Yellow (50-70dB), Red (>70dB)
     * Walkability: Green (>70), Yellow (40-70), Red (<40)
   - Icon indicators
   - Tooltip explanations

10. LOADING STATES:
    - Skeleton screens for property cards
    - Spinner for button actions
    - Progress bars for file uploads
    - Shimmer effect for placeholders

11. NOTIFICATIONS:
    - Toast messages (top-right)
    - Badge count on bell icon
    - Slide-in notification panel
    - Different colors for types (info, success, error)

12. IMAGE GALLERY:
    - Lightbox with keyboard navigation
    - Thumbnails strip
    - Zoom on hover
    - Fullscreen mode

ANIMATIONS & TRANSITIONS:
- Page transitions: Fade (200ms)
- Hover effects: 150ms ease-in-out
- Modal entrance: Scale from 0.95 to 1 + fade
- Button clicks: Ripple effect
- Scroll animations: Fade up on elements entering viewport
- Loading spinners: Smooth rotation
- Success actions: Checkmark animation

RESPONSIVE BREAKPOINTS:
- Mobile: < 640px
- Tablet: 640px - 1024px
- Desktop: > 1024px

MOBILE-SPECIFIC UX:
- Bottom navigation for key actions
- Swipeable property images
- Collapsible filters (drawer)
- Sticky CTA buttons
- Touch-friendly buttons (min 44px height)

ACCESSIBILITY:
- ARIA labels on all interactive elements
- Keyboard navigation support
- Focus indicators
- Alt text for images
- High contrast mode support
- Screen reader compatible

=================================================================
7. ADVANCED FEATURES IMPLEMENTATION DETAILS
=================================================================

FEATURE 1: LIFESTYLE SEARCH ENGINE (WITH AI & MOCK SUPPORT)
------------------------------------------------------------
This is our MOAT - the defensible competitive advantage.

ARCHITECTURE: Three-Layer System
1. Data Collection (Mock/Real switchable)
2. Natural Language Processing (Emergent LLM)
3. Search & Ranking Algorithm

=== LAYER 1: LIFESTYLE DATA COLLECTION ===

When verified property is created/updated:

A. LOCATION EXTRACTION:
   - Use Google Maps Geocoding API (or mock)
   - Convert address â†’ lat/long
   - Mock: Use predefined lat/long for known cities

B. AQI DATA (Air Quality Index):
   REAL MODE (if AQI_API_KEY exists):
   - Call OpenWeatherMap Air Pollution API
   - OR AirVisual API
   - Get real-time AQI for lat/long
   - Update hourly via cron job
   
   MOCK MODE (if AQI_API_KEY is empty):
   - Generate realistic mock based on city:
     * Metro cities (Mumbai, Delhi): 80-120
     * Tier-2 cities: 60-90
     * Suburbs/Hill stations: 30-60
   - Add random variation (Â±10) per locality
   - Cache mock values for consistency

C. WALKABILITY SCORE:
   REAL MODE (if WALKABILITY_API_KEY exists):
   - Call Walk Score API
   - Returns 0-100 score
   
   MOCK MODE:
   - Calculate based on area characteristics:
     * City center/Commercial: 75-90
     * Residential: 60-75
     * Suburbs: 40-60
     * Rural: 20-40
   - Consider nearby amenities count

D. NOISE LEVEL:
   REAL MODE (if noise API available):
   - Estimate based on road proximity
   - Use traffic data APIs
   
   MOCK MODE (always, as real noise APIs are rare):
   - Calculate based on:
     * Distance to main road: <100m = 70dB, 100-500m = 60dB, >500m = 50dB
     * Area type: Commercial = +10dB, Residential = +0dB
     * Floor level: Ground = +5dB, >3rd floor = -5dB
   - Range: 45-75 dB

E. NEARBY AMENITIES:
   REAL MODE (if GOOGLE_PLACES_API_KEY exists):
   - Query Google Places API
   - Find parks, hospitals, schools, malls within 3km
   - Get name, distance, rating
   
   MOCK MODE:
   - Use predefined amenities per locality
   - Example: Koramangala â†’ [
       {type: "park", name: "Srinivasa Park", distance: 0.5},
       {type: "hospital", name: "Apollo", distance: 2.1},
       {type: "school", name: "DPS", distance: 1.2}
     ]
   - Vary distances by Â±0.3km per property

F. STORE LIFESTYLE DATA:
```python
property.lifestyle_data = {
    aqi_score: 65,
    noise_level: 58,
    walkability_score: 72,
    nearby_parks: [...],
    nearby_hospitals: [...],
    nearby_schools: [...],
    nearby_malls: [...],
    public_transport_score: 68,
    safety_score: 75,  # Mock only
    calculated_at: timestamp,
    is_mock: true/false
}
```

=== LAYER 2: NATURAL LANGUAGE SEARCH (EMERGENT LLM) ===

Feature: Convert natural language â†’ structured filters

Example Input: "quiet 2bhk apartment near park in low pollution area under 25000"

LLM Processing (using Emergent LLM Key):
```python
from emergentintegrations import get_llm_client

async def parse_natural_language_search(query: str):
    llm = get_llm_client()  # Uses EMERGENT_LLM_KEY
    
    prompt = f"""Extract search criteria from this property search query:
    "{query}"
    
    Return JSON with these fields (null if not mentioned):
    {{
        "bhk_type": string,
        "property_type": string,
        "max_rent": number,
        "max_aqi": number,
        "max_noise_level": number,
        "min_walkability": number,
        "near_parks": boolean,
        "pet_friendly": boolean,
        "furnished": string,
        "location": string
    }}
    """
    
    response = await llm.complete(prompt)
    filters = json.loads(response)
    
    return filters
```

Output:
```json
{
    "bhk_type": "2BHK",
    "property_type": "apartment",
    "max_rent": 25000,
    "max_aqi": 60,
    "max_noise_level": 55,
    "near_parks": true,
    "pet_friendly": null,
    "furnished": null,
    "location": null
}
```

Fallback (if LLM fails or key missing):
- Simple keyword matching:
  * "quiet" â†’ max_noise_level: 60
  * "low pollution" / "clean air" â†’ max_aqi: 60
  * "walkable" / "near metro" â†’ min_walkability: 70
  * "park" / "green" â†’ near_parks: true
  * "2bhk" / "2 bhk" â†’ bhk_type: "2BHK"
  * Extract numbers for rent

=== LAYER 3: SEARCH & RANKING ALGORITHM ===

MongoDB Aggregation Pipeline:
```python
pipeline = [
    # Stage 1: Filter only verified properties with lifestyle data
    {
        "$match": {
            "is_verified": True,
            "lifestyle_data": {"$exists": True}
        }
    },
    
    # Stage 2: Apply lifestyle filters
    {
        "$match": {
            "lifestyle_data.aqi_score": {"$lte": max_aqi},
            "lifestyle_data.noise_level": {"$lte": max_noise},
            "lifestyle_data.walkability_score": {"$gte": min_walkability},
            "rent": {"$lte": max_rent},
            "bhk_type": bhk_type
        }
    },
    
    # Stage 3: Filter nearby amenities
    {
        "$match": {
            "lifestyle_data.nearby_parks": {"$ne": []}  # if near_parks requested
        }
    },
    
    # Stage 4: Calculate match score
    {
        "$addFields": {
            "match_score": {
                "$sum": [
                    {"$cond": [{"$lte": ["$lifestyle_data.aqi_score", 50]}, 10, 0]},
                    {"$cond": [{"$lte": ["$lifestyle_data.noise_level", 55]}, 10, 0]},
                    {"$cond": [{"$gte": ["$lifestyle_data.walkability_score", 75]}, 10, 0]},
                    {"$cond": [{"$gte": [{"$size": "$lifestyle_data.nearby_parks"}, 1]}, 5, 0]}
                ]
            }
        }
    },
    
    # Stage 5: Sort by match score, then recency
    {
        "$sort": {
            "match_score": -1,
            "created_at": -1
        }
    }
]
```

PREMIUM FEATURE GATING:
- Basic search: Only basic filters (price, BHK, location)
- Lifestyle search: Only for premium renters
- Check user tier before allowing lifestyle filters
- Show upsell modal if free user tries advanced search

UI DISPLAY:
- Show lifestyle scores as visual indicators:
  * AQI: Color-coded badge (Green <50, Yellow 50-100, Red >100)
  * Noise: Sound wave icon with dB value
  * Walkability: Progress bar 0-100
  * Amenities: Icons with distance
- Tooltip explaining each metric
- "Match Score" badge (if using NL search)

FEATURE 2: REVERSE MARKETPLACE (PRIVACY-FIRST)
-----------------------------------------------
Implementation:
1. Anonymous Profile Generation:
   - Don't expose: name, email, phone, exact address
   - Show: anonymized ID, employment type, income range, preferences
   - Example: "Renter #" + user_id.substring(0, 4)

2. Contact Initiation:
   - Owner selects renter profile
   - Clicks "Contact" -> Creates chat
   - Renter receives notification with property details
   - Identity revealed only after renter responds

3. Privacy Controls:
   - Renter can opt out of reverse marketplace
   - Setting in /renter/profile: "Let verified owners find you"

FEATURE 3: CHAT SYSTEM (REST API - WebSocket upgrade later)
-------------------------------------------------------------
PHASE 1 IMPLEMENTATION: REST API Only

Architecture:
- No WebSocket/Socket.io in initial version
- Pure REST API for messaging
- Polling for new messages (optional)
- Simple, reliable, easier to implement

Backend Implementation:
```python
# Chat endpoints
POST /api/chats/initiate
- Creates new chat between renter and owner
- Checks contact limits for free renters
- Returns chat_id

GET /api/chats
- Returns all chats for logged-in user
- Sorted by last_message_at

GET /api/chats/:chat_id
- Returns chat details + all messages
- Marks messages as read

POST /api/chats/:chat_id/messages
- Adds new message to chat
- Updates last_message_at
- Increments unread count for recipient

GET /api/chats/unread-count
- Returns total unread messages count
- For notification badge
```

Frontend Implementation:
1. Chat List Page (/renter/chats or /owner/chats):
   - Fetch all chats on page load
   - Show last message preview
   - Unread count badge
   - Click to open chat

2. Chat Detail View:
   - Fetch chat messages on open
   - Display in WhatsApp-style interface
   - Text input at bottom
   - Send button â†’ POST to API
   - Manual refresh button (or auto-refresh every 5 seconds)

3. Polling (optional):
   - setInterval(() => fetchMessages(), 5000)
   - Only when chat is open
   - Show "New message" indicator

4. Notifications:
   - When new chat created: Show toast
   - When new message: Update unread count
   - Backend endpoint: GET /api/chats/unread-count
   - Poll every 30 seconds when logged in

Message Structure:
```javascript
{
    message_id: uuid,
    sender_id: uuid,
    sender_type: "renter" | "owner",
    sender_name: string,
    message: string,
    timestamp: datetime,
    is_read: boolean,
    attachments: [urls]
}
```

UI Features:
- Message bubbles (left for received, right for sent)
- Timestamp on each message
- "Read" indicator (single/double check)
- Attachment support (images only initially)
- Property info sidebar
- Owner/Renter profile card

Contact Limit Enforcement:
```python
async def initiate_chat(property_id, renter_id):
    renter = await get_user(renter_id)
    
    # Check if free tier
    if renter.subscription_tier == "free":
        if renter.contacts_used >= 5:
            raise HTTPException(
                status_code=403,
                detail="Contact limit reached. Upgrade to premium."
            )
    
    # Create chat
    chat = create_chat(property_id, renter_id, owner_id)
    
    # Increment contact count for free users
    if renter.subscription_tier == "free":
        renter.contacts_used += 1
        await update_user(renter)
    
    return chat
```

FUTURE PHASE: WebSocket Upgrade
- Add Socket.io for real-time messaging
- No polling needed
- Typing indicators
- Online/offline status
- Instant message delivery
- Push notifications

Benefits of REST-first approach:
âœ“ Simpler to implement and debug
âœ“ No connection management complexity
âœ“ Works perfectly for MVP
âœ“ Can upgrade to WebSocket later without changing DB schema
âœ“ Better for testing

FEATURE 4: DOCUMENT VERIFICATION WORKFLOW
------------------------------------------
Implementation:
1. Upload:
   - Frontend: File picker with validation (size, type)
   - Backend: Upload to S3/Cloudinary
   - Store URL in user profile

2. Manual Review:
   - Admin portal (future phase)
   - List of pending verifications
   - Document viewer
   - Approve/Reject buttons
   - Rejection reason

3. Automated Checks (future):
   - OCR for Aadhaar/PAN validation
   - API integration with Govt databases
   - Face matching

FEATURE 5: ANALYTICS & INSIGHTS
--------------------------------
Implementation:
1. Track Events:
   - Property view: Increment analytics.total_views
   - Premium user view: Increment analytics.premium_views
   - Contact initiated: Increment analytics.total_contacts
   - Shortlist: Increment analytics.shortlisted_count

2. Dashboard:
   - Fetch analytics for owner's properties
   - Aggregate totals
   - Time-series data for graph
   - Comparison with avg (stored in separate collection)

3. Insights:
   - If unverified + low views -> Upsell verification
   - If high views but no contacts -> Suggest price/description changes

FEATURE 6: PAYMENT INTEGRATION (RAZORPAY WITH MOCK SUPPORT)
------------------------------------------------------------
Using Razorpay Payment Gateway (India-focused, easier for INR transactions)

ARCHITECTURE: Switchable Mock/Real Implementation

Backend Service Structure:
```python
# payment_service.py
class PaymentService:
    def __init__(self):
        self.razorpay_key = os.getenv('RAZORPAY_KEY_ID')
        self.is_mock = not self.razorpay_key or self.razorpay_key == ''
        
    def create_order(self, amount, currency, metadata):
        if self.is_mock:
            return self._create_mock_order(amount, currency, metadata)
        else:
            return self._create_razorpay_order(amount, currency, metadata)
    
    def verify_payment(self, payment_data):
        if self.is_mock:
            return self._verify_mock_payment(payment_data)
        else:
            return self._verify_razorpay_payment(payment_data)
```

MOCK PAYMENT FLOW:
1. Frontend calls /api/payments/create-order
   - Backend checks: if RAZORPAY_KEY_ID is empty
   - Returns mock order: {
       order_id: "mock_order_" + uuid,
       amount: amount,
       currency: "INR",
       is_mock: true
     }

2. Frontend detects is_mock = true
   - Shows custom mock payment modal (instead of Razorpay)
   - Displays: "TEST MODE - Payment Simulation"
   - Shows payment details (amount, invoice)
   - "Pay Now" button â†’ Simulates 2-second processing
   - Auto-generates mock payment_id

3. Frontend calls /api/payments/verify
   - Backend accepts mock payment_id
   - Always returns success
   - Updates user subscription/verification status
   - Creates transaction record with payment_status: "success"

4. Receipt generation (same for both mock and real)

REAL RAZORPAY FLOW (when keys are added):
1. Create Order:
   - Backend uses Razorpay SDK
   - Creates actual order via Razorpay API
   - Returns {order_id, amount, key_id}

2. Checkout:
   - Frontend opens Razorpay modal (official widget)
   - User enters card/UPI details
   - Completes payment

3. Verification:
   - Razorpay callback with payment_id, order_id, signature
   - Backend verifies signature using Razorpay secret
   - Updates subscription/verification status

4. Webhook (optional):
   - Razorpay sends webhook on payment events
   - Backend handles webhook for additional confirmation

5. Receipt:
   - Generate invoice PDF
   - Email to user (if email service configured)
   - Store in transactions collection

PAYMENT TYPES:
Type 1: Renter Premium Subscription
- Amount: â‚¹750
- Duration: 90 days
- Updates: user.profile.renter_profile.subscription_tier = "premium"
- Sets: subscription_start, subscription_end

Type 2: Property Verification Fee
- Amount: â‚¹2,000
- Per property
- Updates: property.verification_tier = "verified"
- Marks: property.verification_fee_paid = true

UI INDICATORS:
- Mock mode: Show yellow banner "TEST MODE - No real payment"
- Real mode: Show Razorpay logo and "Secure Payment"
- Transaction history: Tag mock transactions with badge

ERROR HANDLING:
- Mock: Never fails (for testing)
- Real: Handle Razorpay errors (card declined, network issues)
- Retry mechanism
- Support contact info

FUTURE ENHANCEMENTS:
- Refund support
- Payment plans (EMI)
- Wallet integration
- Multiple payment methods

FEATURE 7: SMART SEARCH RANKING
--------------------------------
Algorithm:
1. Verified properties always rank higher
2. Within verified:
   - Recency (newer listings first)
   - Completeness (more details = higher rank)
   - Engagement (more views/contacts = higher rank)
3. Unverified properties always at bottom
4. Boost properties with lifestyle data for lifestyle searches

FEATURE 8: CONTACT LIMIT ENFORCEMENT (FREE TIER)
-------------------------------------------------
Implementation:
1. Before creating chat:
   - Check user.profile.renter_profile.contacts_used
   - If >= 5 and not premium:
     * Return error 403
     * Frontend shows upgrade modal
   - If < 5 or premium:
     * Create chat
     * Increment contacts_used

2. Reset:
   - Only by upgrading to premium
   - contacts_used doesn't reset, but limit becomes unlimited

=================================================================
8. SECURITY & PRIVACY CONSIDERATIONS
=================================================================

1. AUTHENTICATION:
   - JWT tokens with expiry (24 hours)
   - Refresh tokens for long sessions
   - Password hashing (bcrypt)
   - Rate limiting on login attempts
   - OTP-based verification for sensitive actions

2. AUTHORIZATION:
   - Middleware checks for protected routes
   - Role-based access (renter/owner/admin)
   - Ownership verification (user can only edit own properties)

3. DATA PRIVACY:
   - Mask phone/email until contact initiated
   - Anonymous reverse marketplace profiles
   - User can control profile visibility
   - GDPR-compliant data deletion

4. DOCUMENT SECURITY:
   - Encrypted storage
   - Access only by authorized admins
   - Auto-delete after verification (optional)

5. PAYMENT SECURITY:
   - No card details stored
   - PCI-DSS compliant gateway
   - SSL/TLS for all transactions

6. API SECURITY:
   - CORS configuration
   - Input validation & sanitization
   - SQL/NoSQL injection prevention
   - Rate limiting
   - HTTPS only

7. CHAT SECURITY:
   - End-to-end encryption (future)
   - Report/block functionality
   - Moderation for spam

=================================================================
9. DEVELOPMENT PHASES
=================================================================

PHASE 1: CORE MVP (4-6 weeks)
------------------------------
Week 1-2: Backend Foundation
- Setup FastAPI project structure
- MongoDB connection & schemas
- Authentication (register, login, JWT)
- User profile CRUD
- Property CRUD APIs
- Basic search API

Week 3-4: Frontend Foundation
- React setup with Tailwind
- Landing page
- Login/Signup pages
- Property search page
- Property detail page
- Basic dashboard

Week 5-6: Core Features
- Chat functionality (REST, no WebSocket yet)
- Free tier contact limit
- Basic payment integration (subscription only)
- Profile management
- Property listing form

DELIVERABLES:
âœ“ Users can register as renter/owner
âœ“ Owners can list properties (free tier)
âœ“ Renters can browse and contact (5 contact limit)
âœ“ Basic subscription payment
âœ“ Simple chat interface

PHASE 2: TRUST & VERIFICATION (3-4 weeks)
------------------------------------------
Week 7-8: Verification System
- Document upload functionality
- Verification status tracking
- Admin review workflow (manual)
- Verified badges display
- Property ranking algorithm

Week 9-10: Premium Features
- Lifestyle data calculation (external APIs)
- Advanced filters UI
- Lifestyle search backend
- Payment for property verification
- Analytics dashboard for owners

DELIVERABLES:
âœ“ Verification workflow for renters & properties
âœ“ Verified badges and trust signals
âœ“ Lifestyle search for premium renters
âœ“ Owner analytics

PHASE 3: REVERSE MARKETPLACE (2-3 weeks)
-----------------------------------------
Week 11-12: Reverse Marketplace
- Anonymous renter profile generation
- Browse renters page for verified owners
- Contact renter functionality
- Privacy controls

DELIVERABLES:
âœ“ Owners can browse verified renters
âœ“ Reverse contact initiation
âœ“ Privacy-first profiles

PHASE 4: POLISH & OPTIMIZATION (2-3 weeks)
-------------------------------------------
Week 13-14: Real-time & UX
- Socket.io integration for chat
- Real-time notifications
- UI/UX improvements
- Mobile responsive optimization
- Loading states & animations

Week 15: Testing & Launch Prep
- Bug fixes
- Performance optimization
- Security audit
- SEO optimization
- Analytics integration (Google Analytics)

DELIVERABLES:
âœ“ Real-time chat
âœ“ Polished UI with animations
âœ“ Mobile optimized
âœ“ Production-ready

FUTURE PHASES (Post-Launch):
-----------------------------
- Reviews & ratings system
- Automated document verification (OCR, API)
- Mobile apps (React Native)
- Advanced matching algorithm (ML)
- Neighborhood guides
- Virtual tours
- Lease management tools
- Payment escrow
- Tenant background checks

=================================================================
10. FEATURE VERIFICATION CHECKLIST
=================================================================

Cross-reference with features.txt to ensure COMPLETE coverage:

âœ… CORE BUSINESS MODEL:
[âœ“] Freemium model (no ads, trust-based monetization)
[âœ“] Two-sided marketplace (renters + owners)
[âœ“] Upfront payment (subscriptions + verification fees)
[âœ“] No commission on final deal
[âœ“] Simple pricing: Free & Limited vs. Paid & Powerful

âœ… RENTER FREE TIER ("Free Browser"):
[âœ“] Free signup (email/phone)
[âœ“] Unlimited browsing of all properties
[âœ“] Basic filters only (Price, BHK-count, Location)
[âœ“] Strict contact limit: 5 properties maximum
[âœ“] Cannot use lifestyle search
[âœ“] Clear upsell when limit reached

âœ… RENTER PREMIUM TIER (â‚¹750 for 90 days):
[âœ“] Unlimited contacts
[âœ“] "Verified Renter" badge
[âœ“] Listed in reverse marketplace (if opted in)
[âœ“] Advanced lifestyle search access
[âœ“] Natural language search capability
[âœ“] Verification option (upload documents)
[âœ“] Employment/income verification

âœ… OWNER FREE TIER ("Free Lister"):
[âœ“] Can list properties for free
[âœ“] Listing marked "Not Verified" warning
[âœ“] Ranked at bottom of search results
[âœ“] No lifestyle data analysis
[âœ“] Not discoverable in lifestyle search
[âœ“] Performance metrics shown (to upsell)

âœ… OWNER VERIFIED TIER (â‚¹2,000 per property):
[âœ“] "Verified Property" badge
[âœ“] Top search ranking (above all free listings)
[âœ“] Lifestyle data enrichment (AQI, noise, walkability)
[âœ“] Discoverable in premium lifestyle searches
[âœ“] Access to reverse marketplace (browse renters)
[âœ“] Document verification (ID + ownership proof)
[âœ“] Property analytics dashboard

âœ… LIFESTYLE SEARCH ENGINE:
[âœ“] AQI (air quality) filtering
[âœ“] Noise level filtering
[âœ“] Walkability score filtering
[âœ“] Proximity to parks
[âœ“] Natural language search ("quiet area near park")
[âœ“] Only for premium renters
[âœ“] Only returns verified properties with lifestyle data
[âœ“] Mock data support (switchable to real APIs)

âœ… REVERSE MARKETPLACE (USP):
[âœ“] Premium renters listed anonymously
[âœ“] Example format: "Renter #1024. IT Professional. Income >15 LPA..."
[âœ“] Only accessible to verified owners
[âœ“] Privacy-first (no name, email, phone revealed)
[âœ“] Owner can initiate contact
[âœ“] Renter can control visibility
[âœ“] Shows: employment type, income range, preferences, move-in date

âœ… VERIFICATION SYSTEM:
[âœ“] Manual document review process
[âœ“] Owner verification:
    - ID proof (Aadhaar/PAN)
    - Ownership proof (electricity bill / property tax / sale deed)
[âœ“] Renter verification:
    - ID proof (Aadhaar/PAN)
    - Income proof (salary slips / bank statements / ITR)
[âœ“] Small internal team review (not automated)
[âœ“] Approval/rejection workflow
[âœ“] Future: Integration with govt. portals (Mahabhulekh, Kaveri)

âœ… TRUST SIGNALS:
[âœ“] Verified property badge (green checkmark)
[âœ“] Verified renter badge (blue star)
[âœ“] Unverified warning (yellow)
[âœ“] Trust-first branding
[âœ“] No ads (premium feel)

âœ… SEARCH & RANKING:
[âœ“] Verified properties always rank higher
[âœ“] Unverified properties at bottom
[âœ“] Basic search: Available to all
[âœ“] Lifestyle search: Premium only
[âœ“] Property completeness affects ranking
[âœ“] Engagement metrics (views, contacts) boost ranking

âœ… PAYMENT SYSTEM:
[âœ“] Razorpay integration
[âœ“] Two payment types:
    - Renter subscription: â‚¹750 for 90 days
    - Property verification: â‚¹2,000 per property
[âœ“] Mock payment flow (switchable)
[âœ“] Transaction history
[âœ“] Invoice generation
[âœ“] Email confirmation

âœ… CHAT SYSTEM:
[âœ“] Renter-to-owner messaging
[âœ“] Owner-to-renter messaging (reverse marketplace)
[âœ“] Contact limit enforcement (5 for free renters)
[âœ“] Message history
[âœ“] Read/unread status
[âœ“] Attachment support
[âœ“] REST API implementation (WebSocket later)

âœ… ANALYTICS & UPSELL:
[âœ“] Owner property analytics:
    - Total views
    - Premium views
    - Contact requests
    - Shortlist count
[âœ“] Performance comparison (verified vs. unverified)
[âœ“] Upsell messaging: "90% fewer views on unverified"
[âœ“] Contact limit counter for free renters
[âœ“] Subscription expiry reminders

âœ… USER PROFILES:
[âœ“] Renter profile with preferences
[âœ“] Owner profile with properties
[âœ“] Employment information
[âœ“] Income details
[âœ“] Document uploads
[âœ“] Privacy controls

âœ… PROPERTY FEATURES:
[âœ“] Comprehensive property details (BHK, rent, deposit, amenities)
[âœ“] Image gallery
[âœ“] Location on map
[âœ“] Lifestyle data display (for verified properties)
[âœ“] Nearby amenities
[âœ“] Property type (apartment, villa, PG, etc.)
[âœ“] Furnishing status
[âœ“] Pet policy
[âœ“] Preferred tenant type

âœ… SECURITY & PRIVACY:
[âœ“] JWT authentication
[âœ“] Password hashing
[âœ“] Document encryption
[âœ“] Anonymous reverse marketplace profiles
[âœ“] User can control profile visibility
[âœ“] Data privacy compliance

âœ… MOCK/PRODUCTION SWITCHABILITY:
[âœ“] All external APIs configurable via .env
[âœ“] Mock data generation for:
    - Payment (Razorpay)
    - AQI data
    - Walkability scores
    - Noise levels
    - Location autocomplete
    - Nearby amenities
[âœ“] No code changes needed to switch modes
[âœ“] Clear indicators when in mock mode

âœ… AI/LLM INTEGRATION:
[âœ“] Emergent LLM key integration
[âœ“] Natural language search processing
[âœ“] Intent extraction from user queries
[âœ“] Fallback to keyword matching

FEATURES NOT INCLUDED (FUTURE PHASES):
[x] Reviews & ratings system
[x] Automated OCR document verification
[x] Mobile apps
[x] Advanced ML matching algorithm
[x] Lease management tools
[x] Payment escrow
[x] Video calls
[x] Virtual tours

=================================================================
11. KEY METRICS TO TRACK
=================================================================

USER METRICS:
- Total signups (renters vs owners)
- Free to premium conversion rate
- Verification completion rate
- Churn rate

ENGAGEMENT METRICS:
- Properties listed per owner
- Average contacts per renter
- Chat response rate
- Time to first contact

REVENUE METRICS:
- MRR (Monthly Recurring Revenue)
- Premium subscription revenue
- Verification fee revenue
- Average order value

MARKETPLACE HEALTH:
- Supply: Total active properties
- Demand: Total active renters
- Match rate: % of renters who find a home
- Verified ratio: % of verified properties

=================================================================
TECHNICAL NOTES FOR IMPLEMENTATION
=================================================================

1. Use environment variables for:
   - MongoDB connection string
   - JWT secret
   - Payment gateway keys
   - External API keys
   - AWS/Cloudinary credentials

2. Implement logging:
   - Request/response logs
   - Error tracking (Sentry)
   - User action logs

3. Database indexing:
   - email, phone (unique indexes)
   - location (geospatial index)
   - property_id, user_id (foreign keys)

4. Caching:
   - Redis for frequently accessed data (optional)
   - Property search results
   - User sessions

5. File upload limits:
   - Images: Max 5MB each, 10 images per property
   - Documents: Max 10MB each

6. Rate limiting:
   - Login: 5 attempts per 15 mins
   - API calls: 100 per minute per user
   - Search: 20 per minute

=================================================================
IMPLEMENTATION GUIDE: MOCK TO PRODUCTION TRANSITION
=================================================================

This section provides clear instructions for developers on how to
implement the switchable mock/production architecture.

BACKEND SERVICE PATTERN (Python/FastAPI):
------------------------------------------

Create service classes with built-in mock detection:

```python
# services/payment_service.py
import os
from typing import Dict, Any
import uuid
from datetime import datetime

class PaymentService:
    def __init__(self):
        self.razorpay_key = os.getenv('RAZORPAY_KEY_ID', '')
        self.razorpay_secret = os.getenv('RAZORPAY_KEY_SECRET', '')
        self.is_mock = not self.razorpay_key
        
        if not self.is_mock:
            import razorpay
            self.client = razorpay.Client(
                auth=(self.razorpay_key, self.razorpay_secret)
            )
    
    def create_order(self, amount: int, currency: str, metadata: Dict[str, Any]):
        """Create payment order - switches between mock and real based on env"""
        if self.is_mock:
            return {
                'order_id': f'mock_order_{uuid.uuid4().hex[:12]}',
                'amount': amount,
                'currency': currency,
                'status': 'created',
                'is_mock': True
            }
        else:
            order_data = {
                'amount': amount * 100,  # Razorpay uses paise
                'currency': currency,
                'notes': metadata
            }
            order = self.client.order.create(data=order_data)
            return {
                'order_id': order['id'],
                'amount': amount,
                'currency': currency,
                'status': order['status'],
                'is_mock': False
            }
    
    def verify_payment(self, payment_data: Dict[str, Any]):
        """Verify payment - mock always succeeds"""
        if self.is_mock:
            return {
                'success': True,
                'payment_id': f'mock_pay_{uuid.uuid4().hex[:12]}',
                'message': 'Mock payment successful'
            }
        else:
            # Real Razorpay signature verification
            try:
                self.client.utility.verify_payment_signature(payment_data)
                return {
                    'success': True,
                    'payment_id': payment_data['razorpay_payment_id'],
                    'message': 'Payment verified'
                }
            except:
                return {
                    'success': False,
                    'message': 'Payment verification failed'
                }
```

```python
# services/lifestyle_service.py
import os
import random
from typing import Dict

class LifestyleDataService:
    def __init__(self):
        self.aqi_api_key = os.getenv('AQI_API_KEY', '')
        self.walkability_api_key = os.getenv('WALKABILITY_API_KEY', '')
        self.is_mock = not (self.aqi_api_key and self.walkability_api_key)
    
    async def get_lifestyle_data(self, latitude: float, longitude: float, 
                                 locality: str, area_type: str):
        """Get lifestyle data - mock or real based on env"""
        if self.is_mock:
            return self._generate_mock_data(locality, area_type)
        else:
            return await self._fetch_real_data(latitude, longitude)
    
    def _generate_mock_data(self, locality: str, area_type: str) -> Dict:
        """Generate realistic mock lifestyle data"""
        # AQI based on location
        aqi_ranges = {
            'metro': (80, 120),
            'tier2': (60, 90),
            'suburb': (40, 70),
            'rural': (30, 50)
        }
        aqi_range = aqi_ranges.get(area_type, (50, 80))
        
        # Walkability based on area type
        walk_ranges = {
            'commercial': (75, 90),
            'residential': (60, 75),
            'suburb': (40, 60),
            'rural': (20, 40)
        }
        walk_range = walk_ranges.get(area_type, (50, 70))
        
        return {
            'aqi_score': random.randint(*aqi_range),
            'noise_level': random.randint(50, 70),
            'walkability_score': random.randint(*walk_range),
            'nearby_parks': self._mock_nearby_amenities('park', locality),
            'nearby_hospitals': self._mock_nearby_amenities('hospital', locality),
            'nearby_schools': self._mock_nearby_amenities('school', locality),
            'public_transport_score': random.randint(60, 85),
            'safety_score': random.randint(65, 85),
            'is_mock': True
        }
    
    def _mock_nearby_amenities(self, amenity_type: str, locality: str):
        """Generate mock nearby amenities"""
        amenity_names = {
            'park': ['Central Park', 'Green Gardens', 'City Park'],
            'hospital': ['Apollo', 'Fortis', 'City Hospital'],
            'school': ['DPS', 'Delhi Public School', 'Ryan International']
        }
        
        count = random.randint(1, 3)
        return [
            {
                'name': f'{random.choice(amenity_names[amenity_type])} {locality}',
                'distance': round(random.uniform(0.3, 2.5), 1)
            }
            for _ in range(count)
        ]
    
    async def _fetch_real_data(self, latitude: float, longitude: float):
        """Fetch real data from external APIs"""
        # Implementation for real API calls
        pass
```

```python
# services/location_service.py
import os
from typing import List, Dict

class LocationService:
    def __init__(self):
        self.google_api_key = os.getenv('GOOGLE_PLACES_API_KEY', '')
        self.is_mock = not self.google_api_key
        
        # Predefined mock data
        self.mock_cities = [
            'Mumbai', 'Delhi', 'Bangalore', 'Hyderabad', 'Chennai',
            'Kolkata', 'Pune', 'Ahmedabad', 'Jaipur', 'Lucknow'
        ]
        
        self.mock_localities = {
            'Bangalore': ['Koramangala', 'Indiranagar', 'Whitefield', 'HSR Layout'],
            'Mumbai': ['Bandra', 'Andheri', 'Powai', 'Thane'],
            'Delhi': ['Connaught Place', 'Karol Bagh', 'Dwarka', 'Rohini']
        }
    
    async def autocomplete(self, query: str) -> List[Dict]:
        """Location autocomplete - mock or real"""
        if self.is_mock:
            return self._mock_autocomplete(query)
        else:
            return await self._google_autocomplete(query)
    
    def _mock_autocomplete(self, query: str) -> List[Dict]:
        """Simple string matching for mock"""
        query_lower = query.lower()
        results = []
        
        # Match cities
        for city in self.mock_cities:
            if query_lower in city.lower():
                results.append({
                    'type': 'city',
                    'name': city,
                    'display': city
                })
        
        # Match localities
        for city, localities in self.mock_localities.items():
            for locality in localities:
                if query_lower in locality.lower():
                    results.append({
                        'type': 'locality',
                        'name': locality,
                        'city': city,
                        'display': f'{locality}, {city}'
                    })
        
        return results[:10]
```

```python
# services/storage_service.py
import os
import uuid
from pathlib import Path

class StorageService:
    def __init__(self):
        self.aws_key = os.getenv('AWS_ACCESS_KEY_ID', '')
        self.cloudinary_key = os.getenv('CLOUDINARY_API_KEY', '')
        self.is_mock = not (self.aws_key or self.cloudinary_key)
        
        if self.is_mock:
            # Create local uploads directory
            self.upload_dir = Path('uploads')
            self.upload_dir.mkdir(exist_ok=True)
    
    async def upload_file(self, file_content: bytes, filename: str, 
                         folder: str) -> str:
        """Upload file - local or cloud based on env"""
        if self.is_mock:
            return self._save_local(file_content, filename, folder)
        else:
            return await self._upload_cloud(file_content, filename, folder)
    
    def _save_local(self, file_content: bytes, filename: str, folder: str) -> str:
        """Save file locally"""
        unique_filename = f'{uuid.uuid4().hex}_{filename}'
        folder_path = self.upload_dir / folder
        folder_path.mkdir(exist_ok=True)
        
        file_path = folder_path / unique_filename
        file_path.write_bytes(file_content)
        
        return f'/uploads/{folder}/{unique_filename}'
```

FRONTEND INTEGRATION:
---------------------

Detect mock mode from API responses and show appropriate UI:

```javascript
// services/paymentService.js
export const initiatePayment = async (amount, type, metadata) => {
    const response = await api.post('/payments/create-order', {
        amount,
        type,
        metadata
    });
    
    const { order_id, amount: orderAmount, is_mock } = response.data;
    
    if (is_mock) {
        // Show mock payment modal
        return showMockPaymentModal(order_id, orderAmount);
    } else {
        // Show real Razorpay modal
        return showRazorpayModal(order_id, orderAmount);
    }
};

const showMockPaymentModal = (orderId, amount) => {
    return new Promise((resolve) => {
        // Show custom modal with "TEST MODE" banner
        // Simulate payment processing
        setTimeout(() => {
            const mockPaymentId = `mock_pay_${Date.now()}`;
            resolve({ payment_id: mockPaymentId, order_id: orderId });
        }, 2000);
    });
};
```

```javascript
// components/LifestyleDataBadge.js
export const LifestyleDataBadge = ({ lifestyleData }) => {
    const { aqi_score, is_mock } = lifestyleData;
    
    return (
        <div className="flex items-center gap-2">
            <span className={`badge ${getAQIColor(aqi_score)}`}>
                AQI: {aqi_score}
            </span>
            {is_mock && (
                <span className="text-xs text-gray-500">(Mock Data)</span>
            )}
        </div>
    );
};
```

MIGRATION CHECKLIST (Mock â†’ Production):
-----------------------------------------

1. PAYMENT (RAZORPAY):
   â–¡ Create Razorpay account at https://razorpay.com
   â–¡ Get API keys (Key ID and Key Secret)
   â–¡ Add to .env:
     RAZORPAY_KEY_ID=rzp_live_xxxxx
     RAZORPAY_KEY_SECRET=xxxxx
   â–¡ Setup webhook URL for payment confirmations
   â–¡ Test in Razorpay test mode first
   â–¡ Switch to live mode
   â–¡ Remove "TEST MODE" banners from UI

2. LIFESTYLE DATA:
   â–¡ Sign up for AQI API (OpenWeatherMap or AirVisual)
   â–¡ Sign up for Walk Score API
   â–¡ Add to .env:
     AQI_API_KEY=xxxxx
     WALKABILITY_API_KEY=xxxxx
   â–¡ Test API responses
   â–¡ Implement caching to reduce API calls
   â–¡ Setup cron job for periodic updates

3. LOCATION SERVICES:
   â–¡ Enable Google Maps and Places APIs
   â–¡ Add to .env:
     GOOGLE_MAPS_API_KEY=xxxxx
     GOOGLE_PLACES_API_KEY=xxxxx
   â–¡ Setup billing in Google Cloud Console
   â–¡ Implement request quotas

4. FILE STORAGE:
   â–¡ Setup AWS S3 bucket or Cloudinary account
   â–¡ Configure bucket permissions
   â–¡ Add to .env:
     AWS_ACCESS_KEY_ID=xxxxx
     AWS_SECRET_ACCESS_KEY=xxxxx
     AWS_S3_BUCKET_NAME=homer-uploads
   â–¡ Migrate existing uploads (if any)

5. EMAIL SERVICE:
   â–¡ Sign up for SendGrid or configure SMTP
   â–¡ Add to .env:
     SENDGRID_API_KEY=xxxxx
   â–¡ Verify sender domain
   â–¡ Test email delivery

6. LLM INTEGRATION:
   â–¡ Already configured (Emergent LLM Key)
   â–¡ No changes needed
   â–¡ Monitor usage and costs

TESTING STRATEGY:
-----------------
1. Test thoroughly with mock data first
2. Switch ONE service at a time to production
3. Keep mock fallbacks for graceful degradation
4. Monitor API usage and costs
5. Setup alerts for API failures

=================================================================
SUMMARY: WHY THIS ARCHITECTURE WINS
=================================================================

1. MOCK-FIRST APPROACH:
   âœ“ Start building immediately without waiting for API approvals
   âœ“ Test all features end-to-end with realistic mock data
   âœ“ Demo-ready for investors/stakeholders without real integrations
   âœ“ Zero external costs during development
   âœ“ Predictable behavior for testing

2. PRODUCTION-READY FROM DAY ONE:
   âœ“ Simply add API keys to .env file
   âœ“ No code refactoring needed
   âœ“ Gradual migration (one service at a time)
   âœ“ Fallback to mock if APIs fail
   âœ“ Built-in error handling

3. TRUST-FIRST BUSINESS MODEL:
   âœ“ Solves chicken-and-egg with free tiers
   âœ“ Monetizes trust (not transactions)
   âœ“ Prevents disintermediation
   âœ“ Clear value proposition for both sides
   âœ“ Dual revenue streams

4. DEFENSIBLE MOAT:
   âœ“ Lifestyle Search Engine (unique data)
   âœ“ Reverse Marketplace (only platform with this)
   âœ“ Verification trust network
   âœ“ AI-powered natural language search
   âœ“ Hard to replicate without significant investment

5. SCALABLE ARCHITECTURE:
   âœ“ REST API design (easy to scale)
   âœ“ MongoDB (flexible schema for iterations)
   âœ“ Service-oriented backend (independent services)
   âœ“ Stateless authentication (JWT)
   âœ“ Caching-ready for performance

6. DEVELOPER-FRIENDLY:
   âœ“ Clear separation of concerns
   âœ“ Environment-driven configuration
   âœ“ Comprehensive API documentation
   âœ“ Reusable service patterns
   âœ“ Easy to onboard new developers

=================================================================
TECHNOLOGY CHOICES RATIONALE
=================================================================

FRONTEND (React + Tailwind):
- React: Industry standard, huge ecosystem, easy to hire for
- Tailwind: Rapid UI development, consistent design, no CSS bloat
- Context/Redux: State management for user auth and app-wide data

BACKEND (FastAPI + Python):
- FastAPI: Modern, fast, auto-generated docs, async support
- Python: Easy to integrate AI/ML, rich ecosystem for data processing
- Type hints: Better code quality and IDE support

DATABASE (MongoDB):
- Flexible schema (easy to iterate on property/user fields)
- Great for nested documents (lifestyle_data, preferences)
- Geospatial queries (location-based search)
- Horizontal scaling for future growth

PAYMENT (Razorpay):
- India-focused (INR is primary currency)
- Easier integration than Stripe for Indian market
- Better support for UPI, wallets, net banking
- Lower fees for domestic transactions

LLM (Emergent Integration):
- Single key for multiple providers
- Cost-effective for startup
- Easy to switch models
- Built-in error handling

REST API (vs GraphQL):
- Simpler for MVP
- Better caching
- Easier to debug
- Standard HTTP methods
- Can add GraphQL later if needed

=================================================================
COMPETITIVE ADVANTAGES
=================================================================

VS. NOBROKER:
- We: Monetize trust upfront (they: commission-based)
- We: Lifestyle search with AI (they: basic filters)
- We: Reverse marketplace (they: one-way only)
- We: Clear pricing (they: hidden charges)

VS. 99ACRES/MAGICBRICKS:
- We: Verified-first approach (they: quantity over quality)
- We: Premium user experience (they: ad-heavy)
- We: Two-way marketplace (they: owner-centric only)
- We: Modern tech stack (they: legacy systems)

VS. FACEBOOK/WHATSAPP GROUPS:
- We: Trust & verification (they: full of scams)
- We: Structured data (they: unorganized)
- We: Advanced search (they: manual scrolling)
- We: Professional platform (they: social networks)

=================================================================
RISKS & MITIGATION
=================================================================

RISK 1: Low initial inventory (owners won't list)
MITIGATION:
- Free tier for owners (zero barrier to entry)
- Seed platform with properties ourselves initially
- Partner with local brokers for inventory
- Offer limited-time free verification

RISK 2: Renters won't pay â‚¹750
MITIGATION:
- Make free tier genuinely useful (not crippled)
- Show clear value (5 contacts run out quickly)
- Premium features are genuinely better (lifestyle search)
- 90-day duration = only â‚¹8/day

RISK 3: Verification bottleneck (manual review)
MITIGATION:
- Start with limited cities (Bangalore only)
- Hire 2-3 part-time reviewers initially
- Set expectations (24-48 hour turnaround)
- Automate parts (Aadhaar validation via API later)

RISK 4: Mock data looks fake/unprofessional
MITIGATION:
- Use realistic ranges for all mock values
- Add slight randomization for variety
- Clear "TEST MODE" indicators
- Beautiful UI makes up for mock data

RISK 5: Competition copies our features
MITIGATION:
- Lifestyle data is expensive to collect
- Reverse marketplace needs trust network (takes time)
- AI-powered search requires expertise
- Fast execution and brand building

=================================================================
SUCCESS METRICS (6 MONTHS POST-LAUNCH)
=================================================================

USER GROWTH:
- Target: 1,000 registered users (500 renters, 500 owners)
- Target: 500 premium conversions

INVENTORY:
- Target: 2,000 property listings
- Target: 30% verified properties (600)

ENGAGEMENT:
- Target: 50% of renters hit contact limit (shows value)
- Target: 200 chats initiated per week
- Target: 20% chat-to-deal conversion

REVENUE:
- Target: â‚¹5 lakhs MRR
  * 300 renter subscriptions = â‚¹2.25 lakhs
  * 150 property verifications = â‚¹3 lakhs
- Target: 15% month-over-month growth

RETENTION:
- Target: 60% renter subscription renewal rate
- Target: 80% verified owners re-list properties

=================================================================
END OF WORKFLOW DOCUMENT
=================================================================

This document serves as the COMPLETE blueprint for the Homer platform.

WHAT'S INCLUDED:
âœ… Complete database schema (7 collections, all fields defined)
âœ… 40+ REST API endpoints with request/response formats
âœ… 26 frontend pages with routing structure
âœ… 7 detailed user flows covering all scenarios
âœ… UI/UX design guidelines (colors, components, animations)
âœ… Advanced features implementation (Lifestyle Search, Reverse Marketplace, AI)
âœ… Mock-first architecture with production switchability
âœ… Razorpay payment integration (mock + real)
âœ… Emergent LLM integration for natural language search
âœ… Security and privacy considerations
âœ… Complete feature verification checklist
âœ… 4-phase development plan (15+ weeks)
âœ… Implementation code patterns and examples
âœ… Migration guide from mock to production
âœ… Competitive analysis and risk mitigation
âœ… Success metrics and KPIs

WHAT'S VERIFIED:
âœ… All features from features.txt are covered
âœ… Freemium model with clear tiers
âœ… Trust-first monetization (no commissions)
âœ… Contact limits (5 for free renters)
âœ… Subscription pricing (â‚¹750 for 90 days)
âœ… Verification fees (â‚¹2,000 per property)
âœ… Lifestyle search (AQI, noise, walkability)
âœ… Natural language search
âœ… Reverse marketplace (anonymous profiles)
âœ… Document verification (manual process)
âœ… Search ranking algorithm
âœ… Analytics and upsell mechanisms

NEXT STEPS:
1. âœ… Review and approve this workflow document
2. â³ Obtain Emergent LLM key (for AI features)
3. â³ Begin Phase 1 implementation (Core MVP)
4. â³ Gather real API keys when ready to go production
5. â³ Launch with mock data, migrate gradually

The platform is designed to be built incrementally, tested thoroughly
with mock data, and seamlessly transition to production by simply
adding API keys to the .env file.

No feature from features.txt has been missed. The architecture is
solid, scalable, and production-ready.

Ready to start building! ðŸš€
