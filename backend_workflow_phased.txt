=================================================================
HOMER - BACKEND WORKFLOW (PHASED APPROACH)
=================================================================

This document breaks down the backend implementation into phases.
Each phase takes approximately 4-5 credits and builds on the previous one.

All phases use MySQL/MariaDB as the database.
- DEVELOPMENT: MariaDB (LLM uses this locally)
- PRODUCTION: MySQL (user's production database with private credentials)
- 100% compatible - same SQL syntax

REFER TO:
- homer_schema.sql for complete database structure
- workflow.txt for overall system design
- phased_implementation_plan.txt for full-stack phases

=================================================================
PHASE 1: BACKEND SETUP + AUTH APIs (4-5 credits)
=================================================================

GOAL: Setup FastAPI backend with database connection and authentication

WHAT TO BUILD:
1. FastAPI project structure
2. MySQL/MariaDB connection with SQLAlchemy
3. User model (users table)
4. Authentication endpoints (register, login, logout)
5. JWT token generation and validation
6. Password hashing
7. Auth middleware

FILES TO CREATE:
- /app/backend/server.py (main FastAPI app)
- /app/backend/requirements.txt
- /app/backend/.env (with DATABASE_URL)
- /app/backend/config/database.py
- /app/backend/config/settings.py
- /app/backend/models/user.py
- /app/backend/routes/auth.py
- /app/backend/utils/jwt_helper.py
- /app/backend/utils/password_helper.py
- /app/backend/middleware/auth_middleware.py

API ENDPOINTS TO IMPLEMENT:
POST /api/auth/register
POST /api/auth/login
POST /api/auth/logout
GET  /api/auth/me

DATABASE:
- Create 'users' table (see homer_schema.sql)
- Use SQLAlchemy ORM
- MariaDB connection: mysql://root@localhost:3306/homer_db

TESTING:
â–¡ Backend starts on port 8001
â–¡ Can register new user
â–¡ Can login and receive JWT token
â–¡ Token validates correctly
â–¡ Protected endpoints require authentication

CREDITS: 4-5

=================================================================
PHASE 2: PROPERTY CRUD APIs (4-5 credits)
=================================================================

GOAL: Complete property management APIs for owners

WHAT TO BUILD:
1. Property model (properties table)
2. Property CRUD endpoints
3. Image upload service (local storage)
4. Property ownership validation
5. Property search API (basic)

FILES TO CREATE:
- /app/backend/models/property.py
- /app/backend/routes/properties.py
- /app/backend/services/property_service.py
- /app/backend/services/storage_service.py
- /app/backend/routes/search.py

API ENDPOINTS TO IMPLEMENT:
POST   /api/properties/create
GET    /api/properties/my-properties
GET    /api/properties/:property_id
PUT    /api/properties/:property_id
DELETE /api/properties/:property_id
POST   /api/properties/:property_id/upload-images
GET    /api/properties/search (basic)

DATABASE:
- Create 'properties' table (see homer_schema.sql)
- Foreign key to users table
- JSON columns for location, details, images

TESTING:
â–¡ Owner can create property
â–¡ Images upload successfully
â–¡ Can retrieve own properties
â–¡ Can update property details
â–¡ Can delete property (soft delete)
â–¡ Basic search returns properties

CREDITS: 4-5

=================================================================
PHASE 3: ADVANCED SEARCH & FILTERS (4-5 credits)
=================================================================

GOAL: Implement search with filters and shortlist functionality

WHAT TO BUILD:
1. Advanced search with filters
2. Search ranking algorithm
3. Shortlist endpoints
4. Property detail endpoint with analytics tracking

FILES TO CREATE:
- /app/backend/services/search_service.py
- /app/backend/models/shortlist.py
- /app/backend/routes/shortlists.py

API ENDPOINTS TO IMPLEMENT:
GET    /api/properties/search (with filters)
GET    /api/properties/:property_id/detail
POST   /api/shortlists/add
GET    /api/shortlists
DELETE /api/shortlists/:shortlist_id

SEARCH FEATURES:
- Filter by city, price range, BHK type, location
- Sort by price, date, verification status
- Pagination (page, limit)
- Verified properties rank higher

DATABASE:
- Create 'shortlists' table (see homer_schema.sql)

TESTING:
â–¡ Search with filters works
â–¡ Pagination works correctly
â–¡ Verified properties rank higher
â–¡ Can add property to shortlist
â–¡ Can view all shortlists
â–¡ Can remove from shortlist

CREDITS: 4-5

=================================================================
PHASE 4: CHAT APIs (4-5 credits)
=================================================================

GOAL: Chat system for renter-owner communication

WHAT TO BUILD:
1. Chat model (chats table)
2. Chat initiation with contact limit check
3. Message sending and retrieval
4. Unread count tracking

FILES TO CREATE:
- /app/backend/models/chat.py
- /app/backend/routes/chats.py
- /app/backend/services/chat_service.py

API ENDPOINTS TO IMPLEMENT:
POST /api/chats/initiate
GET  /api/chats
GET  /api/chats/:chat_id
POST /api/chats/:chat_id/messages
PUT  /api/chats/:chat_id/mark-read
GET  /api/chats/unread-count

CONTACT LIMIT LOGIC:
- Check user.subscription_tier
- If free and contacts_used >= 5: Return 403 error
- If premium or < 5: Create chat and increment contacts_used

DATABASE:
- Create 'chats' table (see homer_schema.sql)
- Messages stored as JSON array

TESTING:
â–¡ Can initiate chat
â–¡ Contact limit enforced for free users
â–¡ Premium users have unlimited contacts
â–¡ Can send and receive messages
â–¡ Unread count updates correctly
â–¡ Messages persist in database

CREDITS: 4-5

=================================================================
PHASE 5: PAYMENT APIs (MOCK + RAZORPAY) (5 credits)
=================================================================

GOAL: Payment system with mock mode and Razorpay integration

WHAT TO BUILD:
1. Transaction model (transactions table)
2. Payment service (switchable mock/real)
3. Subscription payment flow
4. Property verification payment flow
5. Payment history

FILES TO CREATE:
- /app/backend/models/transaction.py
- /app/backend/routes/payments.py
- /app/backend/services/payment_service.py
- /app/backend/utils/razorpay_helper.py

API ENDPOINTS TO IMPLEMENT:
POST /api/payments/create-order
POST /api/payments/verify
GET  /api/payments/history

MOCK MODE:
- If RAZORPAY_KEY_ID is empty â†’ Mock mode
- Generate mock order_id and payment_id
- Always return success
- Store transaction with is_mock=true

REAL MODE:
- If RAZORPAY_KEY_ID exists â†’ Real Razorpay
- Create Razorpay order
- Verify payment signature
- Store transaction

SUBSCRIPTION UPDATE:
- After successful payment:
  * Update user.subscription_tier = 'premium'
  * Set subscription_start and subscription_end
  * Reset contacts_used = 0

DATABASE:
- Create 'transactions' table (see homer_schema.sql)

TESTING:
â–¡ Mock payment flow works
â–¡ Order creation returns correct data
â–¡ Payment verification succeeds
â–¡ User tier updates after payment
â–¡ Contacts reset for new premium users
â–¡ Transaction stored in database
â–¡ Payment history retrieves correctly

CREDITS: 5

=================================================================
PHASE 6: VERIFICATION APIs (4-5 credits)
=================================================================

GOAL: Document upload and verification workflow

WHAT TO BUILD:
1. Storage service for file uploads
2. Document upload endpoints
3. Verification submission endpoints
4. Admin approval/rejection endpoints
5. Secure file serving with authorization

FILES TO CREATE:
- /app/backend/services/storage_service.py (FILE UPLOAD HANDLER)
- /app/backend/routes/verification.py (VERIFICATION ROUTES)
- /app/backend/routes/admin.py (ADMIN ROUTES)

API ENDPOINTS TO IMPLEMENT (MATCHES FRONTEND):
POST   /api/verification/upload-document          # Upload single document
POST   /api/verification/renter/submit             # Submit renter verification
POST   /api/verification/property/submit           # Submit property verification
GET    /api/verification/my-status                 # Get my verification status
GET    /api/verification/admin/pending             # Get pending verifications (admin)
POST   /api/verification/admin/approve/:id         # Approve verification (admin)
POST   /api/verification/admin/reject/:id          # Reject verification (admin)
GET    /uploads/verification/:user_id/:filename    # Serve documents (protected)
GET    /uploads/properties/:property_id/:filename  # Serve property files (public)

=================================================================
âš¡ CRITICAL FILE UPLOAD FLOW (FILES UPLOAD IMMEDIATELY)
=================================================================

ðŸ“± FRONTEND FLOW:
1. User selects file â†’ IMMEDIATELY uploads to backend
   â””â”€> Calls uploadDocument(file, 'id_proof')
   
2. Backend saves file to disk â†’ Returns URL
   â””â”€> File stored: /app/uploads/verification/user_123/abc_1234567890.pdf
   â””â”€> Returns: { file_url: "/uploads/verification/user_123/abc.pdf", ... }
   
3. Frontend stores URL in form state (NOT the file)
   â””â”€> documents.id_proof = { file_url: "/uploads/...", file_name: "aadhaar.pdf" }
   
4. User fills employment details
   
5. User clicks "Submit" â†’ Sends URLs only (NOT files)
   â””â”€> Calls submitRenterVerification({ documents: {...}, employment: {...} })
   
6. Backend stores URLs in MySQL JSON column
   â””â”€> users.renter_verification_documents = { id_proof: { file_url: "..." } }

ðŸ’¾ BACKEND FLOW:
1. POST /api/verification/upload-document receives file
   â””â”€> Validates file type and size
   â””â”€> Saves to /app/uploads/verification/{user_id}/{unique_filename}
   â””â”€> Returns metadata with URL (NOT file data)
   
2. POST /api/verification/renter/submit receives URLs
   â””â”€> Stores URLs in MySQL JSON column
   â””â”€> Updates verification_status = 'pending'
   
3. GET /api/verification/admin/pending returns URLs from MySQL
   â””â”€> Admin sees: { documents: { id_proof: { file_url: "/uploads/..." } } }
   
4. GET /uploads/verification/{user_id}/{filename} serves file
   â””â”€> Checks authorization (admin or owner only)
   â””â”€> Returns actual file from disk

ðŸŽ¯ KEY PRINCIPLE:
- Files go to DISK immediately when uploaded
- URLs go to MySQL when form submitted
- Submit button NEVER sends files (only URLs)
- Admin downloads from DISK using URLs from MySQL

VERIFICATION WORKFLOW (DETAILED):
1. Renter uploads documents via POST /api/verification/upload-document
   - IMMEDIATE UPLOAD: File saved to disk as soon as selected
   - Returns file metadata: {file_name, file_url, file_size, uploaded_at}
   - Files stored in /app/uploads/verification/{user_id}/
   - Frontend stores this metadata (URL) in form state
   
2. Renter fills employment details form
   - No file operations here, just form fields
   
3. Renter submits verification via POST /api/verification/renter/submit
   - Body contains file URLs (from step 1) and employment details
   - NO FILES SENT in this request, only JSON with URLs
   - Stores in MySQL: users.renter_verification_documents (JSON)
   - Updates: users.renter_verification_status = 'pending'
   
4. Admin views pending verifications via GET /api/verification/admin/pending
   - Returns list with document URLs from MySQL
   - Admin sees: { id_proof: { file_url: "/uploads/verification/user_123/abc.pdf" } }
   - Admin can click to view actual files
   
5. Admin views documents via GET /uploads/verification/{user_id}/{filename}
   - Authorization: Only admin or file owner can access
   - Backend reads file from disk using URL
   - Returns actual PDF/image file (FileResponse)
   
6. Admin approves/rejects:
   - Approve: is_verified_renter = true, status = 'verified'
   - Reject: status = 'rejected', reason stored

FILE STORAGE STRUCTURE:
/app/uploads/
â”œâ”€â”€ verification/           # PROTECTED (auth required)
â”‚   â”œâ”€â”€ user_001/
â”‚   â”‚   â”œâ”€â”€ abc12345_1234567890.pdf  # ID proof
â”‚   â”‚   â””â”€â”€ def67890_1234567899.pdf  # Income proof
â”‚   â””â”€â”€ user_002/
â”‚       â””â”€â”€ ...
â”œâ”€â”€ properties/            # PUBLIC (no auth)
â”‚   â”œâ”€â”€ prop_001/
â”‚   â”‚   â”œâ”€â”€ img1_timestamp.jpg
â”‚   â”‚   â””â”€â”€ ...
â”‚   â””â”€â”€ ...
â””â”€â”€ profiles/              # PUBLIC
    â””â”€â”€ ...

MYSQL STORAGE (homer_schema.sql):
- users.renter_verification_documents (JSON column)
  Stores: {
    "id_proof": {
      "type": "aadhaar",
      "file_url": "/uploads/verification/user_123/abc.pdf",
      "file_name": "aadhaar.pdf",
      "uploaded_at": "2025-01-20T10:30:00"
    },
    "income_proof": {...}
  }
- users.employment_info (JSON column)
- users.renter_verification_status (ENUM: none/pending/verified/rejected)

STORAGE SERVICE IMPLEMENTATION:
FILE: /app/backend/services/storage_service.py

```python
import os
import uuid
from datetime import datetime
from fastapi import UploadFile, HTTPException
import aiofiles

UPLOAD_BASE_DIR = os.getenv('UPLOAD_DIR', '/app/uploads')
ALLOWED_EXTENSIONS = {'.pdf', '.jpg', '.jpeg', '.png', '.doc', '.docx'}
MAX_FILE_SIZE = 10 * 1024 * 1024  # 10MB

def get_file_extension(filename: str) -> str:
    return os.path.splitext(filename)[1].lower()

def validate_file(file: UploadFile) -> None:
    ext = get_file_extension(file.filename)
    if ext not in ALLOWED_EXTENSIONS:
        raise HTTPException(400, f"File type not allowed. Allowed: {', '.join(ALLOWED_EXTENSIONS)}")

async def save_file(file: UploadFile, subdirectory: str) -> dict:
    """
    Saves file to disk and returns metadata with URL
    """
    validate_file(file)
    
    # Create directory
    upload_dir = os.path.join(UPLOAD_BASE_DIR, subdirectory)
    os.makedirs(upload_dir, exist_ok=True)
    
    # Generate unique filename
    file_ext = get_file_extension(file.filename)
    unique_filename = f"{uuid.uuid4().hex[:8]}_{int(datetime.now().timestamp())}{file_ext}"
    file_path = os.path.join(upload_dir, unique_filename)
    
    # Save file
    async with aiofiles.open(file_path, 'wb') as f:
        content = await file.read()
        
        if len(content) > MAX_FILE_SIZE:
            raise HTTPException(400, f"File too large. Max: {MAX_FILE_SIZE / (1024*1024)}MB")
        
        await f.write(content)
    
    # Return metadata (URL, not file data)
    file_url = f"/uploads/{subdirectory}/{unique_filename}"
    
    return {
        "file_name": file.filename,
        "file_url": file_url,
        "file_size": len(content),
        "file_type": file.content_type,
        "uploaded_at": datetime.utcnow().isoformat()
    }
```

VERIFICATION ROUTES IMPLEMENTATION:
FILE: /app/backend/routes/verification.py

```python
from fastapi import APIRouter, Depends, UploadFile, File, Form
from services.storage_service import save_file
from models.user import User
from middleware.auth_middleware import get_current_user

router = APIRouter(prefix="/api/verification", tags=["Verification"])

@router.post("/upload-document")
async def upload_verification_document(
    document: UploadFile = File(...),
    document_type: str = Form(...),
    current_user: User = Depends(get_current_user)
):
    """
    IMMEDIATE FILE UPLOAD
    - Receives file as FormData
    - Saves to /app/uploads/verification/{user_id}/
    - Returns URL (not file)
    """
    subdirectory = f"verification/{current_user.user_id}"
    file_metadata = await save_file(document, subdirectory)
    
    return {
        "success": True,
        "data": file_metadata
    }

@router.post("/renter/submit")
async def submit_renter_verification(
    verification_data: dict,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """
    SUBMIT WITH URLS (not files)
    - Receives JSON with file URLs (from upload step)
    - Stores URLs in MySQL JSON column
    """
    current_user.renter_verification_documents = verification_data.get('documents')
    current_user.employment_info = verification_data.get('employment_details')
    current_user.renter_verification_status = 'pending'
    db.commit()
    
    return {
        "success": True,
        "message": "Verification submitted successfully",
        "verification_id": f"renter_{current_user.user_id}",
        "status": "pending"
    }
```

SECURE FILE SERVING:
FILE: /app/backend/server.py (ADD THESE ROUTES)

```python
from fastapi.responses import FileResponse

@app.get("/uploads/verification/{user_id}/{filename}")
async def get_verification_document(
    user_id: str,
    filename: str,
    current_user: User = Depends(get_current_user)
):
    """
    Serve file from disk with authorization
    """
    # Check authorization
    if current_user.user_id != user_id and not current_user.is_admin:
        raise HTTPException(403, "Not authorized to access this file")
    
    file_path = f"/app/uploads/verification/{user_id}/{filename}"
    
    if not os.path.exists(file_path):
        raise HTTPException(404, "File not found")
    
    return FileResponse(file_path)
```

SECURITY:
- Verification documents: Only owner + admin can access
- Property images: Public access
- File type whitelist: .pdf, .jpg, .jpeg, .png, .doc, .docx
- File size limits: 10MB max
- Path traversal protection: Validated paths
- Authorization: JWT token required for verification docs

FRONTEND INTEGRATION:
Frontend already implemented and expects these exact endpoints:
- frontend/src/services/verificationService.js line 370: uploadDocument()
- frontend/src/pages/renter/VerificationUpload.js: Uses upload + submit
- frontend/src/pages/admin/VerificationReview.js: Views pending + approves/rejects

FRONTEND CONTRACT (verificationService.js):
```javascript
// Step 1: Upload file IMMEDIATELY when selected
export const uploadDocument = async (file, documentType) => {
  const formData = new FormData();
  formData.append('document', file);
  formData.append('document_type', documentType);
  
  const response = await axios.post('/api/verification/upload-document', formData);
  // Returns: { success: true, data: { file_url: "/uploads/...", ... } }
  return response.data;
};

// Step 2: Submit with URLs (not files)
export const submitRenterVerification = async (data) => {
  const response = await axios.post('/api/verification/renter/submit', {
    documents: {
      id_proof: { file_url: "...", file_name: "..." },  // URLs only
      income_proof: { file_url: "...", file_name: "..." }
    },
    employment_details: { ... }
  });
  return response.data;
};
```

STEP-BY-STEP TESTING:

1. SETUP:
   â–¡ Create /app/uploads directory structure:
     mkdir -p /app/uploads/verification
     mkdir -p /app/uploads/properties
     mkdir -p /app/uploads/profiles
   â–¡ Set permissions: chmod 755 /app/uploads
   â–¡ Verify backend dependencies installed: aiofiles, python-multipart

2. FILE UPLOAD TEST (IMMEDIATE):
   â–¡ Select file in frontend DocumentUpload component
   â–¡ File immediately uploads (don't wait for submit)
   â–¡ Backend receives FormData with file
   â–¡ File saved to /app/uploads/verification/{user_id}/
   â–¡ Check file exists on disk: ls /app/uploads/verification/{user_id}/
   â–¡ Backend returns metadata: { file_url: "/uploads/...", file_name: "...", file_size: ... }
   â–¡ Frontend stores URL in state (not file)

3. VERIFICATION SUBMISSION TEST (URLS ONLY):
   â–¡ Fill employment details form
   â–¡ Click "Submit Verification"
   â–¡ Network tab shows JSON payload (NO FILES, only URLs)
   â–¡ Backend receives URLs: { documents: { id_proof: { file_url: "..." } } }
   â–¡ MySQL updated: SELECT renter_verification_documents FROM users WHERE user_id = '...';
   â–¡ JSON column contains file URLs (not file data)
   â–¡ Verification status = 'pending'

4. ADMIN PENDING LIST TEST:
   â–¡ Admin logs in
   â–¡ Views pending verifications
   â–¡ GET /api/verification/admin/pending returns list
   â–¡ Each item has documents with file URLs from MySQL
   â–¡ URLs like: "/uploads/verification/user_123/abc_1234567890.pdf"

5. ADMIN FILE VIEW TEST (FROM DISK):
   â–¡ Admin clicks document link
   â–¡ GET /uploads/verification/{user_id}/{filename}
   â–¡ Backend checks authorization (admin or owner)
   â–¡ Backend reads file from disk using URL
   â–¡ Returns FileResponse with actual PDF/image
   â–¡ File displays in browser/downloads

6. AUTHORIZATION TEST:
   â–¡ Non-admin user tries to access another user's document
   â–¡ GET /uploads/verification/other_user_id/file.pdf
   â–¡ Returns 403 Forbidden
   â–¡ Admin can access: Returns 200 with file

7. APPROVAL TEST:
   â–¡ Admin approves verification
   â–¡ POST /api/verification/admin/approve/renter_user_123
   â–¡ MySQL updated: is_verified_renter = true, status = 'verified'
   â–¡ SELECT is_verified_renter, renter_verification_status FROM users WHERE user_id = '...';
   â–¡ Verified badge appears on frontend

8. REJECTION TEST:
   â–¡ Admin rejects verification with reason
   â–¡ POST /api/verification/admin/reject/renter_user_456
   â–¡ Body: { "reason": "Document expired" }
   â–¡ MySQL updated: status = 'rejected'
   â–¡ User sees rejection reason on frontend

9. END-TO-END TEST:
   â–¡ New user registers
   â–¡ Uploads ID proof (immediate) â†’ Check file on disk
   â–¡ Uploads income proof (immediate) â†’ Check file on disk
   â–¡ Fills employment form
   â–¡ Submits verification â†’ Check MySQL has URLs
   â–¡ Admin sees pending request with document URLs
   â–¡ Admin clicks document â†’ Views PDF from disk
   â–¡ Admin approves â†’ User becomes verified
   â–¡ Verified badge shows on user profile

10. PROPERTY IMAGES TEST (PUBLIC):
    â–¡ Owner uploads property images
    â–¡ Files saved to /app/uploads/properties/{property_id}/
    â–¡ URLs stored in properties.images JSON column
    â–¡ GET /uploads/properties/{property_id}/{filename} (no auth)
    â–¡ Returns file (public access)

VALIDATION TESTS:
â–¡ Upload non-PDF/image file â†’ Returns 400 error
â–¡ Upload file > 10MB â†’ Returns 400 error
â–¡ Upload without authentication â†’ Returns 401 error
â–¡ Malformed file path â†’ Returns 404 error
â–¡ Path traversal attempt (../) â†’ Blocked

IMPORTANT NOTES:
âœ… Files NOT stored in MySQL (only file URLs in JSON columns)
âœ… Actual files stored in /app/uploads/ directory
âœ… Upload happens IMMEDIATELY when file selected (not on submit)
âœ… Submit button sends URLs (not files)
âœ… Admin downloads from DISK using URLs from MySQL
âœ… Authorization handled at file serving endpoint level
âœ… Production ready: Can switch to S3/cloud storage by changing save_file() function only

SEE COMPLETE IMPLEMENTATION:
backend_workflow.txt sections 4B, 4C, 4D for full code with all endpoints

CREDITS: 4-5

=================================================================
PHASE 7: LIFESTYLE SEARCH APIs (5 credits)
=================================================================

GOAL: Advanced lifestyle search with mock data generation

WHAT TO BUILD:
1. Lifestyle data calculation service (mock)
2. Lifestyle search endpoint
3. Natural language search with LLM
4. Mock data generators

FILES TO CREATE:
- /app/backend/services/lifestyle_service.py
- /app/backend/services/llm_service.py
- /app/backend/routes/lifestyle.py
- /app/backend/utils/mock_data_generator.py

API ENDPOINTS TO IMPLEMENT:
POST /api/properties/:property_id/calculate-lifestyle
GET  /api/properties/lifestyle-search
POST /api/search/natural-language

LIFESTYLE DATA GENERATION (MOCK):
- AQI score: 30-150 (based on city type)
- Noise level: 45-75 dB (based on location)
- Walkability: 20-90 (based on area type)
- Nearby amenities: Mock with distances
- Calculate automatically for verified properties

LIFESTYLE SEARCH:
- Filter by max_aqi, max_noise, min_walkability
- Filter by near_parks, pet_friendly
- Only premium users can access
- Only verified properties with lifestyle_data

NATURAL LANGUAGE SEARCH:
- Use Emergent LLM Key
- Parse: "quiet 2bhk near park under 25000"
- Extract: {max_noise: 60, bhk: "2BHK", near_parks: true, budget: 25000}
- Fallback to keyword matching if LLM fails

TESTING:
â–¡ Lifestyle data generates for verified properties
â–¡ Mock data is realistic and varied
â–¡ Lifestyle search filters work
â–¡ Natural language parsing works
â–¡ Only premium users can access
â–¡ Results sorted by match score

CREDITS: 5

=================================================================
PHASE 8: REVERSE MARKETPLACE APIs (4-5 credits)
=================================================================

GOAL: Reverse marketplace where owners browse renters

WHAT TO BUILD:
1. Anonymous renter profile generation
2. Renter browse endpoint for owners
3. Owner-initiated contact
4. Privacy controls

FILES TO CREATE:
- /app/backend/routes/reverse_marketplace.py
- /app/backend/services/renter_profile_service.py

API ENDPOINTS TO IMPLEMENT:
GET  /api/reverse-marketplace/renters
POST /api/reverse-marketplace/contact-renter
PUT  /api/users/privacy-settings

ANONYMOUS PROFILE:
- Only premium + verified renters
- Only if profile_visibility = true
- Format: "Renter #" + last 4 digits of user_id
- Show: employment_type, income_range, preferences
- Hide: name, email, phone, exact salary

ACCESS CONTROL:
- Only verified owners can browse
- Only see renters who opted in

OWNER CONTACT:
- Owner selects renter
- Owner sends initial message
- Chat created with initiated_by = 'owner'
- Renter receives notification

TESTING:
â–¡ Renter profiles are anonymized
â–¡ Only verified owners can access
â–¡ Filters work (budget, location, move-in date)
â–¡ Owner can initiate contact
â–¡ Privacy toggle works
â–¡ Chat created correctly

CREDITS: 4-5

=================================================================
PHASE 9: ANALYTICS APIs (4-5 credits)
=================================================================

GOAL: Property analytics and performance tracking

WHAT TO BUILD:
1. Analytics tracking (views, contacts, shortlists)
2. Analytics endpoint
3. Performance comparison
4. Notifications system

FILES TO CREATE:
- /app/backend/routes/analytics.py
- /app/backend/services/analytics_service.py
- /app/backend/models/notification.py
- /app/backend/routes/notifications.py

API ENDPOINTS TO IMPLEMENT:
GET  /api/properties/:id/analytics
POST /api/properties/:id/track-view
GET  /api/analytics/comparison
GET  /api/notifications
PUT  /api/notifications/:id/read

ANALYTICS TRACKING:
- Track total_views on property page load
- Track premium_views if user is premium
- Track total_contacts when chat initiated
- Track shortlisted_count when added
- Store in property.analytics JSON

NOTIFICATIONS:
- New message
- Property viewed
- Verification approved/rejected
- Subscription expiring
- Contact limit warning

DATABASE:
- Create 'notifications' table (see homer_schema.sql)

TESTING:
â–¡ View count increments
â–¡ Premium views tracked separately
â–¡ Contact count updates
â–¡ Analytics endpoint returns data
â–¡ Notifications created and retrieved
â–¡ Can mark notifications as read

CREDITS: 4-5

=================================================================
PHASE 10: POLISH & OPTIMIZATION (3-4 credits)
=================================================================

GOAL: Final polish, testing, and optimization

WHAT TO DO:
1. Add proper error handling
2. Add input validation
3. Optimize database queries
4. Add indexes
5. Test all endpoints
6. Fix bugs
7. Add logging
8. API documentation

TASKS:
- Review all endpoints for error handling
- Add proper HTTP status codes
- Validate all input data
- Add database indexes for performance
- Test with curl/Postman
- Fix any bugs found
- Add request/response logging
- Document API endpoints

TESTING:
â–¡ All endpoints work correctly
â–¡ Error messages are clear
â–¡ Invalid input rejected
â–¡ Database queries optimized
â–¡ No console errors
â–¡ API documentation complete

CREDITS: 3-4

=================================================================
PHASE 11: ADMIN APIs (4-5 credits)
=================================================================

GOAL: Complete admin backend APIs for full database control

WHAT TO BUILD:
1. Admin authentication and authorization middleware
2. Admin statistics endpoint
3. User management APIs (CRUD)
4. Property management APIs (CRUD + force verify)
5. Verification approval/rejection APIs
6. Transaction management APIs (view + refund)
7. Audit logging system
8. Admin dashboard data endpoints

FILES TO CREATE/UPDATE:
- /app/backend/routes/admin.py (new)
- /app/backend/models.py (add AdminAuditLog model)
- /app/backend/auth.py (add require_admin decorator)
- /app/backend/server.py (include admin router)

ADMIN AUTHENTICATION:
```python
# In auth.py
def require_admin(current_user: User = Depends(get_current_user)):
    """Middleware to check if user is admin"""
    if not current_user.is_admin:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Admin access required"
        )
    return current_user
```

ADMIN STATISTICS API:
- Endpoint: GET /api/admin/stats
- Returns:
  * Total users (renters, owners, premium)
  * Total properties (active, verified)
  * Pending verifications count
  * Total revenue
  * Recent activity

USER MANAGEMENT APIs:
- GET /api/admin/users (with filters: user_type, subscription_tier, verification_status)
- GET /api/admin/users/:user_id
- PUT /api/admin/users/:user_id (update any field)
- DELETE /api/admin/users/:user_id
- POST /api/admin/users/:user_id/force-verify

PROPERTY MANAGEMENT APIs:
- GET /api/admin/properties (with filters: status, verification)
- GET /api/admin/properties/:property_id
- PUT /api/admin/properties/:property_id
- DELETE /api/admin/properties/:property_id
- POST /api/admin/properties/:property_id/force-verify

VERIFICATION MANAGEMENT APIs:
- GET /api/admin/verifications/pending
- POST /api/admin/verifications/approve (body: {type, entity_id})
- POST /api/admin/verifications/reject (body: {type, entity_id, reason})

TRANSACTION MANAGEMENT APIs:
- GET /api/admin/transactions (with filters)
- GET /api/admin/transactions/:transaction_id
- POST /api/admin/transactions/:transaction_id/refund

AUDIT LOGGING:
- Every admin action logs to admin_audit_logs table
- Captures: action_type, entity_type, entity_id, old_value, new_value
- Records: IP address, user agent, timestamp
- Endpoint: GET /api/admin/audit-logs (admin only)

AUDIT LOG MODEL:
```python
class AdminAuditLog(Base):
    __tablename__ = "admin_audit_logs"
    
    log_id = Column(String(36), primary_key=True)
    admin_id = Column(String(36), ForeignKey('users.user_id'))
    action_type = Column(String(100), nullable=False)
    entity_type = Column(String(50), nullable=False)
    entity_id = Column(String(36))
    action_details = Column(JSON)
    old_value = Column(JSON)
    new_value = Column(JSON)
    ip_address = Column(String(45))
    user_agent = Column(Text)
    timestamp = Column(DateTime, default=datetime.utcnow)
    status = Column(Enum('success', 'failed', 'partial'))
    error_message = Column(Text)
```

SECURITY FEATURES:
- All admin endpoints require is_admin=True
- JWT token validation
- Rate limiting on admin endpoints
- Audit log for all admin actions
- Cannot delete other admin users
- IP address tracking
- Failed action logging

DATABASE UPDATES:
- Add is_admin column to users table
- Add admin_role column to users table
- Update user_type enum to include 'admin'
- Create admin_audit_logs table

SAMPLE DATA:
- Create admin user: admin@homer.com / admin@123
- user_type = 'admin'
- is_admin = True
- admin_role = 'super_admin'

ADMIN ROUTES IN server.py:
```python
from routes import admin

app.include_router(admin.router)
```

TESTING ADMIN APIs:

1. Admin Login:
```bash
curl -X POST http://localhost:8001/api/auth/login \
  -H "Content-Type: application/json" \
  -d '{
    "email": "admin@homer.com",
    "password": "admin@123"
  }'
```

2. Get Admin Stats:
```bash
curl -X GET http://localhost:8001/api/admin/stats \
  -H "Authorization: Bearer ADMIN_TOKEN"
```

3. Get All Users:
```bash
curl -X GET "http://localhost:8001/api/admin/users?user_type=renter&page=1&limit=50" \
  -H "Authorization: Bearer ADMIN_TOKEN"
```

4. Update User:
```bash
curl -X PUT http://localhost:8001/api/admin/users/user_001 \
  -H "Authorization: Bearer ADMIN_TOKEN" \
  -H "Content-Type: application/json" \
  -d '{
    "subscription_tier": "premium",
    "is_verified_renter": true
  }'
```

5. Delete Property:
```bash
curl -X DELETE http://localhost:8001/api/admin/properties/prop_123 \
  -H "Authorization: Bearer ADMIN_TOKEN"
```

6. Force Verify Property:
```bash
curl -X POST http://localhost:8001/api/admin/properties/prop_456/force-verify \
  -H "Authorization: Bearer ADMIN_TOKEN"
```

7. Approve Verification:
```bash
curl -X POST http://localhost:8001/api/admin/verifications/approve \
  -H "Authorization: Bearer ADMIN_TOKEN" \
  -H "Content-Type: application/json" \
  -d '{
    "verification_type": "renter",
    "entity_id": "user_002"
  }'
```

8. Refund Transaction:
```bash
curl -X POST http://localhost:8001/api/admin/transactions/txn_789/refund \
  -H "Authorization: Bearer ADMIN_TOKEN"
```

9. Get Audit Logs:
```bash
curl -X GET "http://localhost:8001/api/admin/audit-logs?action_type=user_update&page=1" \
  -H "Authorization: Bearer ADMIN_TOKEN"
```

ERROR HANDLING:
- 403 Forbidden if non-admin tries to access
- 404 Not Found for invalid entity IDs
- 400 Bad Request for invalid operations
- All errors logged in audit_logs with status='failed'

RESPONSE FORMATS:
- Success: {"message": "...", "data": {...}}
- Error: {"detail": "...", "error_code": "..."}
- List: {"items": [...], "total_count": N, "page": N, "has_more": bool}

TESTING CHECKLIST:
â–¡ Admin can login
â–¡ Non-admin gets 403 on admin endpoints
â–¡ Admin stats endpoint works
â–¡ Can get all users with filters
â–¡ Can update user details
â–¡ Can delete user
â–¡ Cannot delete admin user
â–¡ Can get all properties
â–¡ Can update property
â–¡ Can delete property
â–¡ Can force verify property
â–¡ Can get pending verifications
â–¡ Can approve verification
â–¡ Can reject verification with reason
â–¡ Can get all transactions
â–¡ Can refund transaction
â–¡ All actions logged in audit_logs
â–¡ Audit logs retrievable
â–¡ IP address captured
â–¡ Error cases handled properly

CREDITS: 4-5

=================================================================
TOTAL BACKEND CREDITS: ~49-55
=================================================================

=================================================================
TIER SYSTEM IMPLEMENTATION SUMMARY (INTEGRATED IN PHASES)
=================================================================

The tier system is the CORE of Homer's business model and is 
integrated throughout all phases above. Here's a quick reference:

RENTER TIERS:
-------------
FREE BROWSER (â‚¹0 forever):
  âœ“ Unlimited browsing
  âœ“ Basic filters only
  âš ï¸ 5 contact limit (enforced in Phase 4 - Chat APIs)
  âŒ No lifestyle search
  âŒ Not in reverse marketplace

PREMIUM RENTER (â‚¹750/90 days):
  âœ“ Unlimited contacts
  âœ“ Verified Renter badge (after document upload)
  âœ“ Advanced lifestyle search (Phase 7)
  âœ“ Reverse marketplace profile (Phase 8)
  âœ“ Natural language AI search

OWNER TIERS:
-----------
FREE LISTER (â‚¹0 forever):
  âœ“ Can list property for free
  âš ï¸ "Not Verified" warning badge
  âš ï¸ Ranked at BOTTOM of search (Phase 3)
  âŒ No lifestyle data
  âŒ Not in lifestyle search
  âŒ No reverse marketplace access

VERIFIED LISTER (â‚¹1,500 per property):
  âœ“ "Verified Property" badge ðŸ†
  âœ“ TOP search ranking (Phase 3)
  âœ“ Lifestyle data enrichment (Phase 7)
  âœ“ Discoverable in lifestyle searches
  âœ“ Reverse marketplace access (Phase 8)
  âœ“ 5-10X more inquiries

KEY IMPLEMENTATION POINTS:
-------------------------
1. Contact Limit (Phase 4):
   - Check user.subscription_tier before chat creation
   - Enforce 5-contact limit for free renters server-side
   - Increment contacts_used after successful chat

2. Search Ranking (Phase 3):
   - ALWAYS sort by is_verified DESC first
   - Then by created_at DESC
   - Verified properties ALWAYS appear first

3. Lifestyle Search (Phase 7):
   - Check subscription_tier == 'premium' before access
   - Only return properties with lifestyle_data != NULL
   - Only verified properties have lifestyle_data

4. Reverse Marketplace (Phase 8):
   - Only premium + verified renters visible
   - Only verified owners can browse
   - Anonymous profiles (RENTER-XXXX format)

5. Payment Flows (Phase 5):
   - Support both mock and real Razorpay
   - Renter subscription: â‚¹750 â†’ premium tier + 90 days
   - Property verification: â‚¹1,500 â†’ pending â†’ admin approval

6. Verification (Phase 6):
   - File upload IMMEDIATELY when selected (not on submit)
   - URLs stored in MySQL JSON columns
   - Admin approval required for verification
   - Lifestyle data calculated after approval

7. Subscription Expiry:
   - Check on every protected endpoint
   - Auto-downgrade to free if expired:
     ```python
     if user.subscription_tier == 'premium':
         if datetime.now() > user.subscription_end:
             user.subscription_tier = 'free'
     ```

8. Analytics & Upsell (Phase 9):
   - Track views, contacts, shortlists
   - Show performance comparison for free owners
   - Display contact counter for free renters

SECURITY RULES:
--------------
âœ“ All tier checks are SERVER-SIDE (never trust frontend)
âœ“ Frontend only displays UI based on tier (locked filters, etc.)
âœ“ Return 403 errors with clear upgrade messages
âœ“ Payment verification before tier upgrades
âœ“ Admin-only verification approval

DATABASE FIELDS (from homer_schema.sql):
---------------------------------------
Users table:
  - subscription_tier (free/premium)
  - subscription_start, subscription_end
  - contacts_used (for free tier)
  - is_verified_renter (TRUE after verification)
  - renter_verification_status (none/pending/verified/rejected)
  - profile_visibility (for reverse marketplace)

Properties table:
  - is_verified (TRUE for verified properties)
  - verification_tier (free/verified)
  - verification_fee_paid (TRUE after payment)
  - lifestyle_data (JSON - calculated for verified only)
  - analytics (JSON - tracks performance)

=================================================================
DEPLOYMENT: MARIADB â†’ MySQL
=================================================================

After completing all phases:

1. EXPORT SCHEMA FROM MARIADB:
   mysqldump -u root -d homer_db > homer_schema.sql

2. IMPORT TO YOUR MySQL:
   mysql -u your_user -p your_database < homer_schema.sql

3. UPDATE .ENV FILE:
   FROM: DATABASE_URL=mysql://root@localhost:3306/homer_db
   TO:   DATABASE_URL=mysql://your_user:your_password@your_host:3306/homer_db

4. RESTART BACKEND:
   sudo supervisorctl restart backend

âœ… ZERO CODE CHANGES REQUIRED!

=================================================================
CRITICAL TIER SYSTEM REMINDERS
=================================================================

1. CONTACT LIMIT: Enforce server-side in chat creation
2. SEARCH RANKING: Verified properties ALWAYS first
3. LIFESTYLE SEARCH: Premium users only
4. REVERSE MARKETPLACE: Verified users only (both sides)
5. PAYMENT VERIFICATION: Before tier upgrades
6. SUBSCRIPTION EXPIRY: Auto-downgrade on expiry
7. BADGES: Display correctly based on verification status
8. UPSELL: Show upgrade CTAs at right moments

These tier features are integrated into phases 1-11 above.
Refer to main backend_workflow.txt for detailed implementation.

=================================================================
END OF BACKEND WORKFLOW (PHASED)
=================================================================